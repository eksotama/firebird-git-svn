/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version HU-I6.0.0.92 **********************/
/*************  history ************
*
*       COMPONENT: PYXIS        MODULE: EDIT.E
*       generated by Marion V2.5     2/6/90
*       from dev              db        on 24-FEB-1994
*****************************************************************
*
*       15601   katz    24-FEB-1994
*       Use STATUS to declare status vectors instead of SLONG
*
*       13392   katz    16-OCT-1993
*       Move away from C language datatypes
*
*       7944    droot   29-MAY-1992
*       clean up
*
*       6652    SCHULDY 15-JUL-1991
*       Allow moving items off screen
*
*       5779    JAS     29-JAN-1991
*       Clean up types for GET_VALUE for port to Cray
*
*/

/*
 *      PROGRAM:        PYXIS Form Package
 *      MODULE:         edit.e
 *      DESCRIPTION:    Form Editor
 *
 * copyright (c) 1986, 1990 by Interbase Software Corporation.
 */

#include "source/jrd/gds.h"
#include "source/pyxis/pyxis.h"
#include "source/pyxis/phase2.h"

/***
#define DEBUG 1
***/

#define INITIAL_MAX     32000

/*DATABASE
    db = STATIC "forms.gdb";*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static ISC_QUAD isc_blob_null = { 0, 0 };	/* initializer for blobs */
static isc_form_handle isc_2;	/* form SIZE_FORM */
static isc_form_handle isc_14;	/* form FORM_NAME */
static isc_form_handle isc_22;	/* form FIELD_EDIT */
static isc_form_handle isc_49;	/* form FIELD_NAME */
static isc_form_handle isc_56;	/* form ENUMERATIONS */
static long *gds__null = 0;		/* dummy status vector */
static isc_db_handle db = 0;	/* database handle */

static isc_tr_handle gds__trans = 0;	/* default transaction handle */
static long
  isc_status[20],				/* status vector */
  isc_status2[20];				/* status vector */
static long
  isc_array_length,				/* array return size */
  SQLCODE;						/* SQL status code */
static isc_win_handle isc_window;	/* window handle */
static short
  isc_width = 80,				/* window width */
  isc_height = 24;				/* window height */
static isc_req_handle isc_0 = 0;	/* request handle */

static short
  isc_1l = 68;
static char
  isc_1[] = {
	1, 4, 0, 8, 0, 8, 0, 8, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 40, 1, 0, 8, 2,
	6, 'H', 'E', 'I',
	'G', 'H', 'T', 0, 0, 5, 0, 2, 5, 'W', 'I', 'D', 'T', 'H', 1, 0, 6, 0, 2,
	12, 'O',
	'U', 'T', 'L', 'I', 'N', 'E', '_', 'F', 'O', 'R', 'M', 7, 0, 4, 0, 5, 3,
	0, -1
};								/* end of form_map string for request isc_1 */

static isc_req_handle isc_12 = 0;	/* request handle */

static short
  isc_13l = 27;
static char
  isc_13[] = {
	1, 4, 0, 2, 0, 7, 0, 40, 31, 0, 9, 2, 9, 'F', 'O', 'R', 'M', '_', 'N',
	'A', 'M',
	'E', 1, 0, 0, 0, -1
};								/* end of form_map string for request isc_13 */

static short
  isc_18l = 67;
static char
  isc_18[] = {
	1, 6, 2, 17, 'R', 101, 118, 101, 114, 115, 101, 32, 111, 112, 116, 105,
	111,
	110, 115, 58, 32, 3, 1, 6, 'I', 'N', 'V', 'E', 'R', 'T', 3, 2, 17, 'R',
	'E', 'V',
	'E', 'R', 'S', 'E', 32, 'O', 'N', 32, 'U', 'P', 'D', 'A', 'T', 'E', 3, 3,
	6,
	'N', 'O', 'R', 'M', 'A', 'L', 3, 4, 4, 'E', 120, 105, 116, -1
};								/* end of blr string for request isc_18 */

static short
  isc_19l = 53;
static char
  isc_19[] = {
	1, 6, 2, 14, 'M', 111, 118, 101, 32, 111, 112, 116, 105, 111, 110, 115,
	58, 32,
	3, 1, 4, 'I', 'T', 'E', 'M', 3, 2, 4, 'S', 'O', 'M', 'E', 3, 3, 4, 'M',
	'O', 'S',
	'T', 3, 4, 3, 'A', 'L', 'L', 3, 5, 4, 'E', 120, 105, 116, -1
};								/* end of blr string for request isc_19 */

static isc_req_handle isc_20 = 0;	/* request handle */

static short
  isc_21l = 191;
static char
  isc_21[] = {
	1, 4, 0, 22, 0, 40, 32, 0, 40, 8, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0,
	7, 0, 7, 0, 7,
	0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 40, 31, 0, 40, 31, 0, 40, -1, 0,
	40, 1, 0, 40,
	1, 0, 8, 2, 8, 'D', 'A', 'T', 'A', 'T', 'Y', 'P', 'E', 1, 0, 13, 0, 2, 5,
	'S', 'C',
	'A', 'L', 'E', 8, 0, 7, 0, 2, 6, 'L', 'E', 'N', 'G', 'T', 'H', 10, 0, 9,
	0, 2, 5,
	'W', 'I', 'D', 'T', 'H', 12, 0, 11, 0, 2, 10, 'F', 'I', 'E', 'L', 'D',
	'_', 'N',
	'A', 'M', 'E', 17, 0, 16, 0, 2, 11, 'E', 'D', 'I', 'T', '_', 'S', 'T',
	'R', 'I',
	'N', 'G', 18, 0, 15, 0, 2, 11, 'F', 'I', 'L', 'L', '_', 'S', 'T', 'R',
	'I', 'N',
	'G', 19, 0, 14, 0, 2, 6, 'U', 'P', 'C', 'A', 'S', 'E', 20, 0, 6, 0, 2, 11,
	'A',
	'L', 'I', 'G', 'N', '_', 'R', 'I', 'G', 'H', 'T', 21, 0, 5, 0, 5, 3, 0, 6,
	0, 0,
	-1
};								/* end of form_map string for request isc_21 */

static short
  isc_46l = 53;
static char
  isc_46[] = {
	1, 6, 2, 8, 'C', 104, 97, 110, 103, 101, 58, 32, 3, 1, 15, 'C', 'H', 'A',
	'R',
	'A', 'C', 'T', 'E', 'R', 'I', 'S', 'T', 'I', 'C', 'S', 3, 2, 12, 'E', 'N',
	'U',
	'M', 'E', 'R', 'A', 'T', 'I', 'O', 'N', 'S', 3, 3, 4, 'E', 'X', 'I', 'T',
	-1
};								/* end of blr string for request isc_46 */

static isc_req_handle isc_47 = 0;	/* request handle */

static short
  isc_48l = 28;
static char
  isc_48[] = {
	1, 4, 0, 2, 0, 7, 0, 40, 31, 0, 9, 2, 10, 'F', 'I', 'E', 'L', 'D', '_',
	'N', 'A',
	'M', 'E', 1, 0, 0, 0, -1
};								/* end of form_map string for request isc_48 */

static short
  isc_53l = 65;
static char
  isc_53[] = {
	1, 6, 2, 8, 'C', 104, 97, 110, 103, 101, 58, 32, 3, 1, 15, 'C', 'H', 'A',
	'R',
	'A', 'C', 'T', 'E', 'R', 'I', 'S', 'T', 'I', 'C', 'S', 3, 2, 6, 'R', 'E',
	'G',
	'I', 'O', 'N', 3, 3, 8, 'S', 'U', 'B', 45, 'I', 'T', 'E', 'M', 3, 4, 4,
	'S', 'I',
	'Z', 'E', 3, 5, 4, 'E', 120, 105, 116, -1
};								/* end of blr string for request isc_53 */

static isc_req_handle isc_54 = 0;	/* request handle */

static short
  isc_55l = 31;
static char
  isc_55[] = {
	1, 4, 0, 4, 0, 45, 0, 0, 7, 0, 7, 0, 7, 0, 8, 2, 6, 'V', 'A', 'L', 'U',
	'E', 'S', 0,
	0, 3, 0, 5, 2, 0, -1
};								/* end of form_map string for request isc_55 */

static short
  isc_62l = 79;
static char
  isc_62[] = {
	1, 6, 2, 13, 'A', 100, 100, 32, 111, 112, 116, 105, 111, 110, 115, 58, 32,
	3,
	1, 4, 'T', 'E', 'X', 'T', 3, 2, 5, 'F', 'I', 'E', 'L', 'D', 3, 3, 15, 'D',
	'A',
	'T', 'A', 'B', 'A', 'S', 'E', 32, 'F', 'I', 'E', 'L', 'D', 'S', 3, 4, 18,
	'R',
	'E', 'P', 'E', 'A', 'T', 'I', 'N', 'G', 32, 'S', 'U', 'B', 45, 'F', 'O',
	'R',
	'M', 3, 5, 4, 'E', 120, 105, 116, -1
};								/* end of blr string for request isc_62 */

static short
  isc_63l = 83;
static char
  isc_63[] = {
	1, 6, 2, 14, 'E', 100, 105, 116, 32, 111, 112, 116, 105, 111, 110, 115,
	58, 32,
	3, 1, 6, 'S', 'E', 'L', 'E', 'C', 'T', 3, 2, 4, 'M', 'O', 'V', 'E', 3, 3,
	3, 'A',
	'D', 'D', 3, 4, 6, 'C', 'H', 'A', 'N', 'G', 'E', 3, 5, 6, 'D', 'E', 'L',
	'E',
	'T', 'E', 3, 6, 7, 'R', 'E', 'V', 'E', 'R', 'S', 'E', 3, 7, 4, 'S', 'A',
	'V',
	'E', 3, 8, 4, 'E', 120, 105, 116, -1
};								/* end of blr string for request isc_63 */


#define gds__blob_null  isc_blob_null	/* compatibility symbols */
#define gds__status     isc_status
#define gds__status2    isc_status2
#define gds__array_length       isc_array_length
#define gds__window     isc_window
#define gds__height     isc_height
#define gds__width      isc_width
#define gds__count      isc_count
#define gds__slack      isc_slack
#define gds__utility    isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
Generate a compile - time error.
	Picking up a V3 include file after preprocessing with V4 GPRE.
#endif
/**** end of GPRE definitions ****//*WINDOW_SCOPE STATIC; */ typedef enum opt_t {
	e_some,
	e_most,
	e_all,
	e_continue
} OPT_T;

extern SCHAR *PYXIS_get_keyname();
extern OBJ PYXIS_get_attribute_value();

static ATT add_text(), add_object(), add_field();
static SLONG edit_field();
static cleanup();

#define FIELD_EDIT      impure [0]
#define RESIZE_FORM     impure [1]
#define NAME_PROMPT     impure [2]
#define ENUMERATION     impure [3]
#define STRING1         impure [4]
#define STRING2         impure [5]
#define STRING3         impure [6]
#define STRING4         impure [7]
#define STRING5         impure [8]
#define STRING6         impure [9]
#define MENU1           impure [10]
#define MENU2           impure [11]
#define MENU3           impure [12]
#define MENU4           impure [13]
#define MENU5           impure [14]
#define MENU6           impure [15]
#define MENU7           impure [16]
#define IMPURE_MAX      17

static OBJ impure[IMPURE_MAX];

static UCHAR field_edit_form[] =
#include "source/pyxis/field_edit.h"
, form_resize[] =
#include "source/pyxis/size_form.h"
, form_form_name[] =
#include "source/pyxis/form_name.h"
, form_field_name[] =
#include "source/pyxis/field_name.h"
, form_enumerations[] =
#include "source/pyxis/enumerations.h"
 ;

typedef struct dtyp {
	UCHAR *dtyp_string;
	USHORT dtyp_internal;
	USHORT dtyp_external;
	USHORT dtyp_length;
} *DTYP;

static struct dtyp dtypes[] = {
	(UCHAR *) "CHAR", dtype_text, blr_text, 0,
	(UCHAR *) "VARYING", dtype_varying, blr_varying, 0,
	(UCHAR *) "SHORT", dtype_short, blr_short, sizeof(SSHORT),
	(UCHAR *) "LONG", dtype_long, blr_long, sizeof(SLONG),
	(UCHAR *) "FLOAT", dtype_real, blr_float, sizeof(float),
	(UCHAR *) "DOUBLE", dtype_double, blr_double, sizeof(double),
#ifdef VMS
	(UCHAR *) "D_FLOAT", dtype_d_float, blr_d_float, sizeof(double),
#else
	(UCHAR *) "D_FLOAT", dtype_double, blr_d_float, sizeof(double),
#endif
	(UCHAR *) "DATE", dtype_date, blr_date, sizeof(GDS__QUAD),
	(UCHAR *) "BLOB", dtype_blob, blr_blob, sizeof(GDS__QUAD),
	NULL, 0, 0
};


PYXIS_edit(window, form, dbb, transaction)
	 WIN window;
	 OBJ form;
	 int *dbb, *transaction;
{
/**************************************
 *
 *      P Y X I S _ e d i t
 *
 **************************************
 *
 * Functional description
 *      Edit a form.  Mostly slop fields around.  Return TRUE
 *      if anything really changed.
 *
 **************************************/
	OBJ object;
	ATT attribute, next;
	SLONG stat;
	STATUS status[20];
	USHORT c, value, x, y, change;

	gds__window = (int *) window;
	change = FALSE;
	set_prototypes(form, FALSE);

#ifdef DEBUG
	if (!FIELD_EDIT && dbb) {
		PYXIS_load_form(status, dbb, transaction, &FIELD_EDIT,
						0, "FIELD_EDIT");
		PYXIS_load_form(status, dbb, transaction, &RESIZE_FORM,
						0, "SIZE_FORM");
		PYXIS_load_form(status, dbb, transaction, &ENUMERATION,
						0, "ENUMERATIONS");
	}
#endif

	for (attribute = NULL;;) {
		if (!attribute)
			attribute = (ATT) PYXIS_find_object(form, 0, att_any, TRUE);
		set_tag_string(window, &STRING6,
					   "EDIT: Move cursor to object and hit %s",
					   PYXIS__KEY_ENTER);
		object = (attribute) ? attribute->att_value : NULL;
		if (object) {
			value = GET_VALUE(object, att_reverse_video);
			REPLACE_ATTRIBUTE(object, att_reverse_video, attype_numeric,
							  !value);
		}
		c = PYXIS_get_char(window, object, 0, 0);
		if (object)
			REPLACE_ATTRIBUTE(object, att_reverse_video, attype_numeric,
							  value);
		PYXIS_pop_form(window);
		switch (c) {
		case PYXIS__KEY_RIGHT:
		case PYXIS__KEY_DOWN:
		case PYXIS__KEY_LEFT:
		case PYXIS__KEY_UP:
		case '\t':
			if (attribute
				&& (next = (ATT) PYXIS_navigate(form, attribute, att_any, c)))
				attribute = next;
			break;

		case PYXIS__KEY_SCROLL_TOP:
			PYXIS_scroll_reset(window->win_form);
			break;

		case PYXIS__KEY_ENTER:
		default:
			if (c != PYXIS__KEY_ENTER && c != '\n')
				PYXIS_return_char(window, c);
			/*CASE_MENU (MENU_HANDLE MENU1 HORIZONTAL) "Edit options: " */
			switch (isc_menu
					((long *) 0L, &isc_window, &MENU1, &isc_63l, isc_63)) {

				/*MENU_ENTREE "SELECT": */
			case 1:
				continue;

				/*MENU_ENTREE "MOVE": */
				break;
			case 2:
				if (!object)
					break;
				change |= move(window, form, object, attribute);

				/*MENU_ENTREE "ADD": */
				break;
			case 3:
				if (next = add_object(window, form, object, dbb, transaction)) {
					attribute = next;
					change = TRUE;
				}

				/*MENU_ENTREE "CHANGE": */
				break;
			case 4:
				if (!object)
					break;
				x = GET_VALUE(object, att_display_x);
				y = GET_VALUE(object, att_display_y);
				if (attribute->att_name == att_label) {
					set_tag_string(window, &STRING1,
								   "EDIT ADD_TEXT: Enter replacement text, terminate with <RETURN> or %s",
								   PYXIS__KEY_ENTER);
					add_text(window, form, x, y, object);
					PYXIS_pop_form(window);
					change = TRUE;
				}
				else
					edit_field(window, object, x, y, dbb, transaction);

				/*MENU_ENTREE "DELETE": */
				break;
			case 5:
				if (!object)
					break;
				if (!
					(next =
					 (ATT) PYXIS_find_object(form, attribute, att_any,
											 TRUE))) next =
						(ATT) PYXIS_find_object(form, attribute, att_any,
												FALSE);
				PYXIS_delete_attribute(form, attribute);
				attribute = next;
				change = TRUE;

				/*MENU_ENTREE "REVERSE": */
				break;
			case 6:
				if (object)
					if (attribute->att_name == att_label) {
						value = !GET_VALUE(object, att_reverse_video);
						REPLACE_ATTRIBUTE(object, att_reverse_video,
										  attype_numeric, value);
						change = TRUE;
					}
					else
						change |= reverse(object);

				/*MENU_ENTREE "SAVE": */
				break;
			case 7:
				save_form(window, form, dbb, transaction);

				/*MENU_ENTREE "Exit": */
				break;
			case 8:
				/* set_prototypes (form, TRUE); */
				return change;
				/*END_MENU */
				break;
			};
		}
	}
}

static ATT add_field(form, field)
	 OBJ form, field;
{
/**************************************
 *
 *      a d d _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Incrementally add a field to a form.
 *
 **************************************/
	OBJ label;
	ATT attribute, attr;
	USHORT x1, y1, x2, y2, min_width;
	TEXT *name;

/* Make up field label */

	name = GET_STRING(field, att_field_name);
	label = (OBJ) PYXIS_create_object(name, att_literal_string);

	if (!(min_width = default_position(form, att_label, &x1, &y1)))
		min_width = label->obj_width;

	x1 += min_width;
	x1 = MAX(x1, label->obj_width);
	PYXIS_position(label, x1 - label->obj_width, y1);
	attribute = (ATT) PUT_ATTRIBUTE(form, att_label, attype_object, label);
	PYXIS_move(form, label);

	PYXIS_delete_named_attribute(field, att_inactive);

	if (attr = (ATT) GET_ATTRIBUTE(field, att_fill_string))
		PYXIS_set_display_attribute(field, attr);

	default_position(form, att_field, &x2, &y2);
	if (y1 == y2)
		x2 = MAX(x1 + 2, x2);

	PYXIS_position(field, x2, y2);
	REPLACE_ATTRIBUTE(field, att_reverse_for_update, attype_numeric, TRUE);
	PUT_ATTRIBUTE(form, att_field, attype_object, field);
	PYXIS_move(form, field);

	return attribute;
}

static ATT add_object(window, form, object, dbb, transaction)
	 WIN window;
	 OBJ form, object;
	 int *dbb, *transaction;
{
/**************************************
 *
 *      a d d _ o b j e c t
 *
 **************************************
 *
 * Functional description
 *      Drive sub-menu to add objects to form.
 *
 **************************************/
	OBJ field;
	USHORT c, x, y, change;

/*CASE_MENU (MENU_HANDLE MENU2 HORIZONTAL) "Add options: ";*/
	switch (isc_menu((long *) 0L, &isc_window, &MENU2, &isc_62l, isc_62)) {
		/*MENU_ENTREE "TEXT": */
	case 1:
		x = y = 0;
		if (object) {
			x = GET_VALUE(object, att_display_x);
			y = GET_VALUE(object, att_display_y);
		}
		set_tag_string(window, &STRING2,
					   "EDIT ADD_TEXT: Enter text, terminate with <RETURN> or %s",
					   PYXIS__KEY_ENTER);
		field = (OBJ) add_text(window, form, x, y, 0);
		PYXIS_pop_form(window);
		return (ATT) field;

		/*MENU_ENTREE "FIELD": */
		break;
	case 2:
		field = (OBJ) PYXIS_create_object(0, 0);
		default_position(form, att_field, &x, &y);
		edit_field(window, field, x, y, dbb, transaction);
		if (!GET_VALUE(field, att_field_name)) {
			PYXIS_delete_object(field);
			return NULL;
		}
		return add_field(form, field);

		/*MENU_ENTREE "DATABASE FIELDS": */
		break;
	case 3:
		return (ATT) copy_fields(window, form, object, dbb, transaction);

		/*MENU_ENTREE "REPEATING SUB-FORM": */
		break;
	case 4:
		return (ATT) add_repeating(window, form, object, dbb, transaction);

		/*MENU_ENTREE "Exit": */
		break;
	case 5:
		return NULL;

/*END_MENU*/
		break;
	};
}

static add_repeating(window, form, object, dbb, transaction)
	 WIN window;
	 OBJ form, object;
	 int *dbb, *transaction;
{
/**************************************
 *
 *      a d d _ r e p e a t i n g
 *
 **************************************
 *
 * Functional description
 *      Add a repeating sub-form box.
 *
 **************************************/
	OBJ form_menu, entree, sub_form, box;
	ATT attribute;
	TEXT *form_name;
	USHORT x, y;

/* Generate and format relation menu */

	form_menu = (OBJ) PYXIS_forms(dbb, transaction);
	PYXIS_format_menu(form_menu, "Select Sub-Form", FALSE);
	x = (window->win_width - GET_VALUE(form_menu, att_width)) / 2;
	PYXIS_position(form_menu, x, 1);

/* Let user select relation.  If he doesn't pick anything, give up and
   go away */

	PYXIS_push_form(window, form_menu, FALSE);
	entree = (OBJ) PYXIS_menu(window, form_menu);

	if (!entree) {
		PYXIS_pop_form(window);
		PYXIS_delete_object(form_menu);
		return NULL;
	}

/* Pick up relation name, and build field menu */

	form_name = GET_STRING(entree, att_literal_string);
	PYXIS_load_form(gds__status, dbb, transaction, &sub_form, 0, form_name);
	PYXIS_compute_size(sub_form, &x, &y);

/* Set up box to hold sub-form */

	box = (OBJ) PYXIS_create_object(0, 0);
	PUT_ATTRIBUTE(box, att_border, attype_numeric, 1);
	PUT_ATTRIBUTE(box, att_blank, attype_numeric, 1);
	PUT_ATTRIBUTE(box, att_box, attype_numeric, 1);
	PUT_ATTRIBUTE(box, att_width, attype_numeric, x + 2);
	PUT_ATTRIBUTE(box, att_height, attype_numeric, 3 * y + 2);
	PUT_ATTRIBUTE(box, att_prototype, attype_object, sub_form);
	PUT_ATTRIBUTE(box, att_field_name, attype_string, form_name);

/* Position box someplace */

	default_position(form, att_field, &x, &y);
	PYXIS_position(box, x, y);
	PUT_ATTRIBUTE(box, att_dtype, attype_numeric, dtype_short);
	PUT_ATTRIBUTE(box, att_length, attype_numeric, sizeof(SSHORT));
	add_field(form, box);

/* Clean up */

	PYXIS_pop_form(window);
	PYXIS_delete_object(form_menu);

	return NULL;
}

static ATT add_text(window, form, x, y, object)
	 WIN window;
	 OBJ form;
	 SLONG x, y;
	 OBJ object;
{
/**************************************
 *
 *      a d d _ t e x t
 *
 **************************************
 *
 * Functional description
 *      Add literal text to a form.  Follow cursor movements until
 *      a significant character shows up, then gobble text.
 *
 **************************************/
	UCHAR text[256], *p;
	ATT attribute, attr;
	SSHORT c;

/* Unless we're doing a straight replacement, follow cursor keys
   until text shows up */

	p = text;

	if (object)
		attribute = (ATT) GET_ATTRIBUTE(form, att_label);
	else {
		c = position(window, form, &x, &y);

		if (c == '\n')
			return NULL;

		*p++ = c;
		object = (OBJ) PYXIS_create_object(0, 0);
		PYXIS_position(object, x, y);
		attribute =
			(ATT) PUT_ATTRIBUTE(form, att_label, attype_object, object);
		PYXIS_move(form, object);
	}

/* Gobble characters until carriage return */

	*p = 0;

	for (;;) {
		attr =
			(ATT) REPLACE_ATTRIBUTE(object, att_literal_string, attype_string,
									text);
		PYXIS_set_display_attribute(object, attr);
		REPLACE_ATTRIBUTE(object, att_width, attype_numeric, p - text);
		c = PYXIS_get_char(window, object, p - text, 0);
		switch (c) {
		case PYXIS__KEY_UP:
		case PYXIS__KEY_DOWN:
		case PYXIS__KEY_RIGHT:
		case PYXIS__KEY_LEFT:
		case PYXIS__KEY_ENTER:
		case '\n':
			return attribute;

		case PYXIS__KEY_DELETE:
			if (p > text)
				*--p = 0;
			break;

		default:
			*p++ = c;
			*p = 0;
		}
	}
}

static cleanup()
{
/**************************************
 *
 *      c l e a n u p
 *
 **************************************
 *
 * Functional description
 *      Cleanup module statics to keep Apollo shared
 *      images happy.
 *
 **************************************/
	OBJ *p, *end;

	gds__window = NULL;
/*CLEAR_HANDLES*/
	{
		isc_0 = 0;
		isc_12 = 0;
		isc_20 = 0;
		isc_47 = 0;
		isc_54 = 0;
	};

	for (p = impure, end = p + IMPURE_MAX; p < end;)
		*p++ = NULL;
}

static copy_fields(window, form, object, dbb, transaction)
	 WIN window;
	 OBJ form, object;
	 int *dbb, *transaction;
{
/**************************************
 *
 *      c o p y _ f i e l d s
 *
 **************************************
 *
 * Functional description
 *      Copy fields from dbb onto form.
 *
 **************************************/
	OBJ relation_menu, field_menu, entree, field;
	ATT attribute;
	TEXT *relation_name;
	USHORT x, y;

/* Generate and format relation menu */

	relation_menu = (OBJ) PYXIS_relations(dbb, transaction);
	PYXIS_format_menu(relation_menu, "Select Relation", FALSE);
	x = (window->win_width - GET_VALUE(relation_menu, att_width)) / 2;
	PYXIS_position(relation_menu, x, 1);

/* Let user select relation.  If he doesn't pick anything, give up and
   go away */

	PYXIS_push_form(window, relation_menu, FALSE);
	entree = (OBJ) PYXIS_menu(window, relation_menu);

	if (!entree) {
		PYXIS_pop_form(window);
		PYXIS_delete_object(relation_menu);
		return NULL;
	}

/* Pick up relation name, and build field menu */

	relation_name = GET_STRING(entree, att_literal_string);
	field_menu = (OBJ) PYXIS_relation_fields(dbb, transaction, relation_name);
	PYXIS_format_menu(field_menu, "Select Field(s)", FALSE);
	PYXIS_position(field_menu, x + strlen(relation_name), 3);
	PYXIS_push_form(window, field_menu, FALSE);
	PYXIS_select(window, field_menu, att_entree, 0);

/* Pick up selected fields, if any */

	for (attribute = NULL;
		 attribute =
		 (ATT) PYXIS_find_object(field_menu, attribute, att_entree, TRUE);) {
		entree = attribute->att_value;
		if (GET_VALUE(entree, att_reverse_video) &&
			(field = GET_OBJECT(entree, att_entree_value))) {
			x = 0;
			y = 0;
			field = (OBJ) PYXIS_clone(field);
			PYXIS_field_defaults(field);
			add_field(form, field, &x, &y);
		}
	}

/* Clean up */

	PYXIS_pop_form(window);
	PYXIS_pop_form(window);
	PYXIS_delete_object(field_menu);
	PYXIS_delete_object(relation_menu);

	return NULL;
}

static default_position(form, type, x_ptr, y_ptr)
	 OBJ form;
	 ATT_N type;
	 USHORT *x_ptr, *y_ptr;
{
/**************************************
 *
 *      d e f a u l t _ p o s i t i o n
 *
 **************************************
 *
 * Functional description
 *      Compute the default position of an object of a given type.
 *
 **************************************/
	OBJ entree;
	USHORT x, y, max_x, max_y, min_width, count;
	ATT attribute;

	max_x = max_y = count = 0;
	min_width = 9999;
	attribute = NULL;

	if (type == att_label)
		attribute = (ATT) PYXIS_find_object(form, attribute, type, TRUE);

	while (attribute = (ATT) PYXIS_find_object(form, attribute, type, TRUE)) {
		entree = attribute->att_value;
		++count;
		max_x = MAX(max_x, entree->obj_rel_x);
		max_y = MAX(max_y, entree->obj_rel_y);
		min_width = MIN(min_width, entree->obj_width);
	}

	*x_ptr = max_x;
	*y_ptr = max_y + ((count < 10) ? 2 : 1);

	return (count) ? min_width : 0;
}

static edit_enumerations(window, field)
	 WIN window;
	 OBJ field;
{
	struct {
		ISC_QUAD isc_58;		/* VALUES */
		short isc_59;			/* gds__form_control */
		short isc_60;			/* TERMINATOR */
		short isc_61;			/* gds__form_control */
	} isc_57;
/**************************************
 *
 *      e d i t _ e n u m e r a t i o n s
 *
 **************************************
 *
 * Functional description
 *      Update enumerations, if any, for a field.
 *
 **************************************/
	OBJ values, value;
	ATT attribute;
	TEXT *data;
	USHORT width, height, x, y, index;

	manual_load(&ENUMERATION, form_enumerations);
	PYXIS_compute_size(ENUMERATION, &width, &height);
	x = (window->win_width - width) / 2;
	y = (window->win_height - height) / 2;
	PYXIS_position(ENUMERATION, x, y);
	values = (OBJ) PYXIS_find_field(ENUMERATION, "VALUES");

/*FOR_FORM (FORM_HANDLE ENUMERATION TRANSPARENT) X IN ENUMERATIONS*/
	{
		if (!ENUMERATION)
			isc_load_form((long *) 0L, &db, &gds__trans, &ENUMERATION,
						  (short *) 0, "ENUMERATIONS");
		if (!isc_54)
			isc_compile_map((long *) 0L, &ENUMERATION, &isc_54, &isc_55l,
							isc_55);
		isc_reset_form((long *) 0L, &isc_54);
		PYXIS_purge_segments(values, 1);
		for (index = 1, attribute = NULL;
			 attribute = (ATT) PYXIS_find_enumeration(field, attribute, TRUE);
			 ++index) PYXIS_put_segment(values, attribute->att_value, index);
		/*DISPLAY X ACCEPTING VALUES */
		{
			isc_57.isc_59 = 0;
			isc_57.isc_61 = 2;
			isc_drive_form((long *) 0L, &db, &gds__trans, &isc_window,
						   &isc_54, &isc_57, &isc_57);
		};
		if (					/*X.TERMINATOR */
			   isc_57.isc_60 != PYXIS__KEY_ENTER) {
			pyxis__pop_window(&gds__window);
			return;
		}
		PYXIS_delete_named_attribute(field, att_enumeration);
		for (index = 1; value = (OBJ) PYXIS_find_index(values, index);
			 index++) if ((data = GET_STRING(value, att_update_data))
						  || (data = GET_STRING(value, att_data)))
				PUT_ATTRIBUTE(field, att_enumeration, attype_string, data);
/*END_FORM*/
		isc_pop_window((long *) 0L, &isc_window);
	};
}

static SLONG edit_field(window, field, x, y, dbb, transaction)
	 WIN window;
	 OBJ field;
	 USHORT x, y;
	 int *dbb, *transaction;
{
	struct {
		char isc_24[32];		/* TERMINATING_FIELD */
		char isc_25[8];			/* DATATYPE */
		short isc_26;			/* gds__form_control */
		short isc_27;			/* TERMINATOR */
		short isc_28;			/* gds__form_control */
		short isc_29;			/* gds__form_control */
		short isc_30;			/* gds__form_control */
		short isc_31;			/* gds__form_control */
		short isc_32;			/* SCALE */
		short isc_33;			/* gds__form_control */
		short isc_34;			/* LENGTH */
		short isc_35;			/* gds__form_control */
		short isc_36;			/* WIDTH */
		short isc_37;			/* gds__form_control */
		short isc_38;			/* gds__form_control */
		short isc_39;			/* gds__form_control */
		short isc_40;			/* gds__form_control */
		char isc_41[31];		/* FIELD_NAME */
		char isc_42[31];		/* EDIT_STRING */
		char isc_43[255];		/* FILL_STRING */
		char isc_44[1];			/* UPCASE */
		char isc_45[1];			/* ALIGN_RIGHT */
	} isc_23;
	struct {
		short isc_51;			/* gds__form_control */
		char isc_52[31];		/* FIELD_NAME */
	} isc_50;
/**************************************
 *
 *      e d i t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Edit characteristics of a field.  If the field doesn't exits,
 *      make one up.
 *
 **************************************/
	OBJ prototype;
	DTYP dtype;
	USHORT length, width, offset, height, c;
	UCHAR *string, *p;
	SLONG scale;
	BOOLEAN fnam_upd, edstr_upd, fstr_upd, scale_upd, w_upd;

/* If this is a sub-form, just re-size it for now */

	if (prototype = GET_OBJECT(field, att_prototype))
		/*CASE_MENU (MENU_HANDLE MENU3 HORIZONTAL) "Change: " */
		switch (isc_menu((long *) 0L, &isc_window, &MENU3, &isc_53l, isc_53)) {

			/*MENU_ENTREE "CHARACTERISTICS": */
		case 1:
			manual_load(&NAME_PROMPT, form_field_name);
			/*FOR_FORM (TAG FORM_HANDLE NAME_PROMPT) F IN FIELD_NAME */
			{
				if (!NAME_PROMPT)
					isc_load_form((long *) 0L, &db, &gds__trans, &NAME_PROMPT,
								  (short *) 0, "FIELD_NAME");
				if (!isc_47)
					isc_compile_map((long *) 0L, &NAME_PROMPT, &isc_47,
									&isc_48l, isc_48);
				isc_reset_form((long *) 0L, &isc_47);
				strcpy(			/*F.FIELD_NAME */
						  isc_50.isc_52, GET_VALUE(field, att_field_name));
				/*DISPLAY F DISPLAYING FIELD_NAME ACCEPTING FIELD_NAME WAKING ON FIELD_NAME */
				{
					isc_50.isc_51 = 7;
					isc_drive_form((long *) 0L, &db, &gds__trans, &isc_window,
								   &isc_47, &isc_50, &isc_50);
				};
				if (			/*F.FIELD_NAME.STATE */
					   isc_50.isc_51 == PYXIS_OPT_USER_DATA)
					REPLACE_ATTRIBUTE(field, att_field_name, attype_string,	/*F.FIELD_NAME */
									  isc_50.isc_52);
				/*END_FORM */
				isc_pop_window((long *) 0L, &isc_window);
			};
			return;

			/*MENU_ENTREE "REGION": */
			break;
		case 2:
			size_form(window, field);
			return;

			/*MENU_ENTREE "SUB-ITEM": */
			break;
		case 3:
			PYXIS_edit(window, prototype, dbb, transaction);
			return;

			/*MENU_ENTREE "SIZE": */
			break;
		case 4:
			size_form(window, prototype);
			return;

			/*MENU_ENTREE "Exit": */
			break;
		case 5:
			return;
			/*END_MENU */
			break;
		}
	else
		/*CASE_MENU (MENU_HANDLE MENU4 HORIZONTAL) "Change: " */
		switch (isc_menu((long *) 0L, &isc_window, &MENU4, &isc_46l, isc_46)) {
			/*MENU_ENTREE "CHARACTERISTICS": */
		case 1:

			/*MENU_ENTREE "ENUMERATIONS": */
			break;
		case 2:
			return edit_enumerations(window, field);

			/*MENU_ENTREE "EXIT": */
			break;
		case 3:
			return;
			/*END_MENU */
			break;
		};

/* Set up data type */

	dtype = dtypes;

	if (c = GET_VALUE(field, att_datatype)) {
		for (dtype = dtypes; dtype->dtyp_string; dtype++)
			if (c == dtype->dtyp_external)
				break;
	}
	else if (c = GET_VALUE(field, att_dtype)) {
		for (dtype = dtypes; dtype->dtyp_string; dtype++)
			if (c == dtype->dtyp_internal)
				break;
	}

	if (!dtype->dtyp_string)
		dtype = dtypes;

/* Initialize the field edit form, if necessary */

	manual_load(&FIELD_EDIT, field_edit_form);

	PYXIS_compute_size(FIELD_EDIT, &width, &height);
	x = MIN(x, window->win_width - width - 1);
	y = MIN(y, window->win_height - height - 1);
	PYXIS_position(FIELD_EDIT, x, y);

/*FOR_FORM (FORM_HANDLE FIELD_EDIT TRANSPARENT) X IN FIELD_EDIT*/
	{
		if (!FIELD_EDIT)
			isc_load_form((long *) 0L, &db, &gds__trans, &FIELD_EDIT,
						  (short *) 0, "FIELD_EDIT");
		if (!isc_20)
			isc_compile_map((long *) 0L, &FIELD_EDIT, &isc_20, &isc_21l,
							isc_21);
		isc_reset_form((long *) 0L, &isc_20);
		put_string(				/*X.FIELD_NAME */
					  isc_23.isc_41, sizeof	/*X.FIELD_NAME */
					  isc_23.isc_41, field, att_field_name);
		put_string(				/*X.EDIT_STRING */
					  isc_23.isc_42, sizeof	/*X.EDIT_STRING */
					  isc_23.isc_42, field, att_edit_string);
		put_string(				/*X.FILL_STRING */
					  isc_23.isc_43, sizeof	/*X.FILL_STRING */
					  isc_23.isc_43, field, att_fill_string);
		strcpy(					/*X.DATATYPE */
				  isc_23.isc_25, dtype->dtyp_string);
		/*X.WIDTH */
		isc_23.isc_36 = GET_VALUE(field, att_width);
		/*X.LENGTH */
		isc_23.isc_34 = GET_VALUE(field, att_length);
		/*X.SCALE */
		isc_23.isc_32 = GET_VALUE(field, att_scale);
		strcpy(					/*X.UPCASE */
				  isc_23.isc_44, (GET_VALUE(field, att_upcase)) ? "Y" : "N");
		strcpy(					/*X.ALIGN_RIGHT */
				  isc_23.isc_45,
				  (GET_VALUE(field, att_insert_right)) ? "Y" : "N");
		fnam_upd = edstr_upd = fstr_upd = scale_upd = w_upd = FALSE;

		/* Update all fields */

		for (;;) {
			if (dtype->dtyp_length) {
				/*X.LENGTH */
				isc_23.isc_34 = dtype->dtyp_length;
				/*X.LENGTH.STATE */
				isc_23.isc_33 = PYXIS_OPT_DISPLAY;
			}
			else
				/*X.LENGTH.STATE */
				isc_23.isc_33 = PYXIS_OPT_UPDATE | PYXIS_OPT_DISPLAY;

			switch (dtype->dtyp_internal) {
			case dtype_short:
			case dtype_long:
			case dtype_quad:
				/*X.SCALE.STATE */
				isc_23.isc_31 = PYXIS_OPT_DISPLAY | PYXIS_OPT_UPDATE;
				break;

			default:
				/*X.SCALE.STATE */
				isc_23.isc_31 = 0;
			}

			/*DISPLAY X DISPLAYING * ACCEPTING * WAKING ON DATATYPE OVERRIDING LENGTH, SCALE */
			{
				isc_23.isc_26 = 3;
				isc_23.isc_28 = 3;
				isc_23.isc_29 = 3;
				isc_23.isc_30 = 3;
				isc_23.isc_35 = 3;
				isc_23.isc_37 = 7;
				isc_23.isc_38 = 3;
				isc_23.isc_39 = 3;
				isc_23.isc_40 = 3;
				isc_drive_form((long *) 0L, &db, &gds__trans, &isc_window,
							   &isc_20, &isc_23, &isc_23);
			};
			for (dtype = dtypes; dtype->dtyp_string; dtype++)
				if (!strcmp(	/*X.DATATYPE */
							   isc_23.isc_25, dtype->dtyp_string))
					break;

			if (				/*X.FIELD_NAME.STATE */
				   isc_23.isc_40 == PYXIS_OPT_USER_DATA)
				fnam_upd = TRUE;
			if (				/*X.EDIT_STRING.STATE */
				   isc_23.isc_39 == PYXIS_OPT_USER_DATA)
				edstr_upd = TRUE;
			if (				/*X.FILL_STRING.STATE */
				   isc_23.isc_38 == PYXIS_OPT_USER_DATA)
				fstr_upd = TRUE;
			if (				/*X.SCALE.STATE */
				   isc_23.isc_31 == PYXIS_OPT_USER_DATA)
				scale_upd = TRUE;
			if (				/*X.WIDTH.STATE */
				   isc_23.isc_35 == PYXIS_OPT_USER_DATA)
				w_upd = TRUE;
			if (strcmp(			/*X.TERMINATING_FIELD */
						  isc_23.isc_24, "DATATYPE"))
				break;
		}

		if (					/*X.TERMINATOR */
			   isc_23.isc_27 == PYXIS__KEY_ENTER) {
			REPLACE_ATTRIBUTE(field, att_dtype, attype_numeric,
							  dtype->dtyp_internal);
			REPLACE_ATTRIBUTE(field, att_length, attype_numeric,	/*X.LENGTH */
							  isc_23.isc_34);

			if (fnam_upd)
				REPLACE_ATTRIBUTE(field, att_field_name, attype_string,	/*X.FIELD_NAME */
								  isc_23.isc_41);

			if (edstr_upd)
				REPLACE_ATTRIBUTE(field, att_edit_string, attype_string,	/*X.EDIT_STRING */
								  isc_23.isc_42);

			if (fstr_upd)
				REPLACE_ATTRIBUTE(field, att_fill_string, attype_string,	/*X.FILL_STRING */
								  isc_23.isc_43);

			if (scale_upd)
				REPLACE_ATTRIBUTE(field, att_scale, attype_numeric,	/*X.SCALE */
								  isc_23.isc_32);

			if (w_upd) {
				REPLACE_ATTRIBUTE(field, att_width, attype_numeric,	/*X.WIDTH */
								  isc_23.isc_36);
				if (dtype->dtyp_internal == dtype_text &&	/*X.LENGTH */
					isc_23.isc_34 !=	/*X.WIDTH */
					isc_23.isc_36)
					REPLACE_ATTRIBUTE(field, att_length, attype_numeric,	/*X.WIDTH */
									  isc_23.isc_36);
			}

			PYXIS_field_defaults(field);

			if (				/*X.UPCASE */
				   isc_23.isc_44[0] == 'Y')
				REPLACE_ATTRIBUTE(field, att_upcase, attype_numeric, TRUE);
			else
				PYXIS_delete_named_attribute(field, att_upcase);

			if (				/*X.ALIGN_RIGHT */
				   isc_23.isc_45[0] == 'Y')
				REPLACE_ATTRIBUTE(field, att_insert_right, attype_numeric,
								  TRUE);
			else
				PYXIS_delete_named_attribute(field, att_insert_right);
		}
/*END_FORM*/
		isc_pop_window((long *) 0L, &isc_window);
	};

	return (SLONG) field;
}

static manual_load(handle, def)
	 OBJ *handle;
	 UCHAR *def;
{
/**************************************
 *
 *      m a n u a l _ l o a d 
 *
 **************************************
 *
 * Functional description
 *      Manually load a form from a literal, unless it is
 *      already loaded.
 *
 **************************************/

	if (!*handle)
		*handle = (OBJ) PYXIS_load(&def);
}

static motion(window, form, field, x_ptr, y_ptr)
	 WIN window;
	 OBJ form, field;
	 int *x_ptr, *y_ptr;
{
/**************************************
 *
 *      m o t i o n
 *
 **************************************
 *
 * Functional description
 *      Pick up a single cursor motion, including count.
 *      Compute new coordinates, and return character.
 *
 **************************************/
	SSHORT x, y;
	SSHORT c, count, cnt, border;

	border = GET_VALUE(form, att_border);
	x = *x_ptr;
	y = *y_ptr;
	count = 0;

/*  Sensitize any mouse movement.  */

	window->win_flags |= WIN_sensitive;

	for (;;) {
		if (field)
			c = PYXIS_get_char(window, field, 0, 0);
		else
			c = PYXIS_get_char(window, form, x + border, y + border);
		cnt = (count) ? count : 1;
		switch (c) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			count = count * 10 + c - '0';
			continue;

		case PYXIS__KEY_UP:
			if (window->win_flags & WIN_synthesized)
				cnt = 1;
			y -= cnt;
			if (y < 0)
				y = 0;
			count = 0;
			break;

		case PYXIS__KEY_DOWN:
			if (window->win_flags & WIN_synthesized)
				cnt = 1;
			y += cnt;
			count = 0;
			break;

		case PYXIS__KEY_LEFT:
			if (window->win_flags & WIN_synthesized)
				cnt = 1;
			x -= cnt;
			if (x < 0)
				x = 0;
			count = 0;
			break;

		case PYXIS__KEY_RIGHT:
			if (window->win_flags & WIN_synthesized)
				cnt = 1;
			x += cnt;
			count = 0;
			break;

		default:
			break;
		}
		*x_ptr = x;
		*y_ptr = y;
		window->win_flags &= ~WIN_sensitive;
		return c;
	}
}

static move(window, form, object, start)
	 WIN window;
	 OBJ form, object;
	 ATT start;
{
/**************************************
 *
 *      m o v e
 *
 **************************************
 *
 * Functional description
 *      Move an object around.  Return TRUE if it really moved.
 *
 **************************************/
	OBJ first;
	ATT attribute, attr;
	OPT_T option;
	USHORT c, change, reverse;
	SLONG x, y, min_x, min_y, delta_x, delta_y;

/*CASE_MENU (MENU_HANDLE MENU5 HORIZONTAL) "Move options: "*/
	switch (isc_menu((long *) 0L, &isc_window, &MENU5, &isc_19l, isc_19)) {
		/*MENU_ENTREE "ITEM": */
	case 1:
		return move_item(window, form, object);

		/*MENU_ENTREE "SOME": */
		break;
	case 2:
		option = e_some;

		/*MENU_ENTREE "MOST": */
		break;
	case 3:
		option = e_most;

		/*MENU_ENTREE "ALL": */
		break;
	case 4:
		option = e_all;

		/*MENU_ENTREE "Exit": */
		break;
	case 5:
		return FALSE;
/*END_MENU*/
		break;
	};

/* Mass move -- start by saving current states of reverse video */

	change = FALSE;
	attribute = NULL;

	while (attribute =
		   (ATT) PYXIS_find_object(form, attribute, att_any, TRUE)) {
		object = attribute->att_value;
		REPLACE_ATTRIBUTE(object, att_temp, attype_numeric,
						  GET_VALUE(object, att_reverse_video));
		REPLACE_ATTRIBUTE(object, att_reverse_video, attype_numeric,
						  (option == e_some) ? FALSE : TRUE);
	}

/* Let user make fine adjustments */

	if (option != e_all) {
		set_tag_string(window, &STRING4,
					   "EDIT MOVE: use <RETURN> to select/deselect items", 0);
		PYXIS_select(window, form, att_any, start);
		PYXIS_pop_form(window);
	}

/* Find the top, rightmost selected object */

	attribute = NULL;
	first = NULL;
	min_x = min_y = INITIAL_MAX;

	while (attribute =
		   (ATT) PYXIS_find_object(form, attribute, att_any, TRUE)) {
		object = attribute->att_value;
		if (GET_VALUE(object, att_reverse_video)) {
			x = GET_VALUE(object, att_display_x);
			y = GET_VALUE(object, att_display_y);
			min_x = MIN(min_x, x);
			min_y = MIN(min_y, y);
			if (!first)
				first = object;
		}
	}

/* Move group */

	x = min_x;
	y = min_y;

	for (;;) {
		delta_x = x;
		delta_y = y;
		set_tag_string(window, &STRING5,
					   "EDIT MOVE: Use cursor keys to move field; hit %s when done",
					   PYXIS__KEY_ENTER);
		c = motion(window, form, first, &x, &y);
		PYXIS_pop_form(window);
		if (c == PYXIS__KEY_ENTER || c == '\n')
			break;
		switch (c) {
		case PYXIS__KEY_UP:
		case PYXIS__KEY_DOWN:
		case PYXIS__KEY_LEFT:
		case PYXIS__KEY_RIGHT:
			break;

		default:
			continue;
		}
		delta_x = x - delta_x;
		delta_y = y - delta_y;
		change = TRUE;
		form->obj_flags |= OBJ_changed;
		while (attribute =
			   (ATT) PYXIS_find_object(form, attribute, att_any, TRUE)) {
			object = attribute->att_value;
			if (GET_VALUE(object, att_reverse_video)) {
				min_x = GET_VALUE(object, att_display_x);
				min_y = GET_VALUE(object, att_display_y);
				PYXIS_position(object, min_x + delta_x, min_y + delta_y);
			}
		}
	}

/* Restore original reverse video */

	while (attribute =
		   (ATT) PYXIS_find_object(form, attribute, att_any, TRUE)) {
		object = attribute->att_value;
		if (attr = (ATT) GET_ATTRIBUTE(object, att_temp)) {
			PYXIS_move(form, object);
			REPLACE_ATTRIBUTE(object, att_reverse_video, attype_numeric,
							  attr->att_value);
			PYXIS_delete_attribute(object, attr);
			attribute = NULL;
		}
	}

	return change;
}

static move_item(window, form, object)
	 WIN window;
	 OBJ form, object;
{
/**************************************
 *
 *      m o v e _ i t e m
 *
 **************************************
 *
 * Functional description
 *      Move an object around.  Return TRUE if it really moved.
 *
 **************************************/
	USHORT c, change;
	SLONG x, y;

	change = FALSE;
	x = GET_VALUE(object, att_display_x);
	y = GET_VALUE(object, att_display_y);

	for (;;) {
		set_tag_string(window, &STRING3,
					   "EDIT MOVE: Use cursor keys to move field; hit %s when done",
					   PYXIS__KEY_ENTER);
		/*  c = motion (window, form, &x, &y);  */
		c = motion(window, form, object, &x, &y);
		PYXIS_pop_form(window);
		switch (c) {
		case PYXIS__KEY_UP:
		case PYXIS__KEY_DOWN:
		case PYXIS__KEY_LEFT:
		case PYXIS__KEY_RIGHT:
			break;

		case '\n':
		case PYXIS__KEY_ENTER:
			PYXIS_move(form, object);
			return change;

		default:
			continue;
		}
		change = TRUE;
		PYXIS_position(object, x, y);
		form->obj_flags |= OBJ_changed;
	}
}

static position(window, form, x_ptr, y_ptr)
	 WIN window;
	 OBJ form;
	 int *x_ptr, *y_ptr;
{
/**************************************
 *
 *      p o s i t i o n
 *
 **************************************
 *
 * Functional description
 *      Position ourselves somewhere within the form.  Stop
 *      on a significant character and return.
 *
 **************************************/
	SSHORT c;

	for (;;)
		switch (c = motion(window, form, 0, x_ptr, y_ptr)) {
		case PYXIS__KEY_UP:
		case PYXIS__KEY_DOWN:
		case PYXIS__KEY_LEFT:
		case PYXIS__KEY_RIGHT:
			break;

		default:
			return c;
		}
}

static put_string(target, target_size, field, attribute)
	 UCHAR *target;
	 int target_size;
	 OBJ field;
	 USHORT attribute;
{
/**************************************
 *
 *      p u t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *      Copy string from form field to form.
 *
 **************************************/
	TEXT *string;

	if (!(string = GET_STRING(field, attribute)))
		string = "";

	strncpy(target, string, target_size);
}

static reverse(object)
	 OBJ object;
{
/**************************************
 *
 *      r e v e r s e
 *
 **************************************
 *
 * Functional description
 *      Set reverse video family of attributes.
 *
 **************************************/
	SLONG value;

/*CASE_MENU (MENU_HANDLE MENU6 HORIZONTAL) "Reverse options: "*/
	switch (isc_menu((long *) 0L, &isc_window, &MENU6, &isc_18l, isc_18)) {
		/*MENU_ENTREE "INVERT": */
	case 1:
		value = !GET_VALUE(object, att_reverse_video);
		REPLACE_ATTRIBUTE(object, att_reverse_video, attype_numeric, value);
		return TRUE;

		/*MENU_ENTREE "REVERSE ON UPDATE": */
		break;
	case 2:
		REPLACE_ATTRIBUTE(object, att_reverse_for_update, attype_numeric,
						  TRUE);
		PYXIS_delete_named_attribute(object, att_reverse_video);
		return TRUE;

		/*MENU_ENTREE "NORMAL": */
		break;
	case 3:
		PYXIS_delete_named_attribute(object, att_reverse_for_update);
		PYXIS_delete_named_attribute(object, att_reverse_video);
		return TRUE;

		/*MENU_ENTREE "Exit": */
		break;
	case 4:
		return FALSE;

/*END_MENU*/
		break;
	};
}

static save_form(window, form, dbb, transaction)
	 WIN window;
	 OBJ form;
	 int *dbb, *transaction;
{
	struct {
		short isc_16;			/* gds__form_control */
		char isc_17[31];		/* FORM_NAME */
	} isc_15;
/**************************************
 *
 *      s a v e _ f o r m
 *
 **************************************
 *
 * Functional description
 *      Save a form in a dbb.
 *
 **************************************/

	manual_load(&NAME_PROMPT, form_form_name);

/*FOR_FORM (TAG FORM_HANDLE NAME_PROMPT) F IN FORM_NAME*/
	{
		if (!NAME_PROMPT)
			isc_load_form((long *) 0L, &db, &gds__trans, &NAME_PROMPT,
						  (short *) 0, "FORM_NAME");
		if (!isc_12)
			isc_compile_map((long *) 0L, &NAME_PROMPT, &isc_12, &isc_13l,
							isc_13);
		isc_reset_form((long *) 0L, &isc_12);
		for (;;) {
			/*DISPLAY F ACCEPTING FORM_NAME WAKING ON FORM_NAME */
			{
				isc_15.isc_16 = 6;
				isc_drive_form((long *) 0L, &db, &gds__trans, &isc_window,
							   &isc_12, &isc_15, &isc_15);
			};
			if (				/*F.FORM_NAME.STATE */
				   isc_15.isc_16 != PYXIS_OPT_USER_DATA || validate_name(	/*F.FORM_NAME */
																			isc_15.isc_17))
				break;
		}
		if (					/*F.FORM_NAME.STATE */
			   isc_15.isc_16 == PYXIS_OPT_USER_DATA)
			PYXIS_store_form(dbb, transaction,	/*F.FORM_NAME */
							 isc_15.isc_17, form);
/*END_FORM*/
		isc_pop_window((long *) 0L, &isc_window);
	};
}

static set_prototypes(object, state)
	 OBJ object;
	 USHORT state;
{
/**************************************
 *
 *      s e t _ p r o t o t y p e s
 *
 **************************************
 *
 * Functional description
 *      Set prototypes active or inactive.
 *
 **************************************/
	OBJ sub;
	ATT attribute;

	for (attribute = object->obj_attributes; attribute;
		 attribute =
		 attribute->att_next) if (attribute->att_type == attype_object) {
			sub = attribute->att_value;
			if (attribute->att_name == att_prototype)
				REPLACE_ATTRIBUTE(sub, att_inactive, attype_numeric, state);
			set_prototypes(sub, state);
		}
}

static set_tag_string(window, ptr, string, keycode)
	 WIN window;
	 OBJ *ptr;
	 UCHAR *string, keycode;
{
/**************************************
 *
 *      s e t _ t a g _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *      Set up tag string, including a possible key name.
 *
 **************************************/

	UCHAR buffer[100];

	if (!*ptr) {
		if (keycode) {
			sprintf(buffer, string, PYXIS_get_keyname(window, keycode));
			string = buffer;
		}
		*ptr = (OBJ) PYXIS_create_object(string, att_literal_string);
	}

	PYXIS_push_tag(window, *ptr);
}

static size_form(window, form)
	 WIN window;
	 OBJ form;
{
	struct {
		long isc_4;				/* HEIGHT */
		long isc_5;				/* WIDTH */
		short isc_6;			/* gds__form_control */
		short isc_7;			/* TERMINATOR */
		short isc_8;			/* gds__form_control */
		short isc_9;			/* gds__form_control */
		short isc_10;			/* gds__form_control */
		char isc_11[1];			/* OUTLINE_FORM */
	} isc_3;
/**************************************
 *
 *      s i z e _ f o r m
 *
 **************************************
 *
 * Functional description
 *      Change size or outline of form.
 *
 **************************************/
	UCHAR *p;
	USHORT c, width, height, x, y, box;

	manual_load(&RESIZE_FORM, form_resize);
	PYXIS_compute_size(RESIZE_FORM, &x, &y);
	x = (window->win_width - x) / 2;
	y = (window->win_height - y) / 2;
	PYXIS_position(RESIZE_FORM, x, y);

/* Compute "current" size of form */

	box = GET_VALUE(form, att_box);
	width = GET_VALUE(form, att_width);
	height = GET_VALUE(form, att_height);
	PYXIS_compute_size(form, &x, &y);

	if (!width)
		width = x + 2;
	if (!height)
		height = y + 2;

	REPLACE_ATTRIBUTE(form, att_blank, attype_numeric, TRUE);

/*FOR_FORM (FORM_HANDLE RESIZE_FORM TRANSPARENT) X IN SIZE_FORM*/
	{
		if (!RESIZE_FORM)
			isc_load_form((long *) 0L, &db, &gds__trans, &RESIZE_FORM,
						  (short *) 0, "SIZE_FORM");
		if (!isc_0)
			isc_compile_map((long *) 0L, &RESIZE_FORM, &isc_0, &isc_1l,
							isc_1);
		isc_reset_form((long *) 0L, &isc_0);
		/*X.WIDTH */
		isc_3.isc_5 = width;
		/*X.HEIGHT */
		isc_3.isc_4 = height;
		strcpy(					/*X.OUTLINE_FORM */
				  isc_3.isc_11, (box) ? "Y" : "N");
		/*DISPLAY X DISPLAYING * ACCEPTING * */
		{
			isc_3.isc_6 = 3;
			isc_3.isc_8 = 3;
			isc_3.isc_9 = 3;
			isc_3.isc_10 = 3;
			isc_drive_form((long *) 0L, &db, &gds__trans, &isc_window, &isc_0,
						   &isc_3, &isc_3);
		};
		if (					/*X.TERMINATOR */
			   isc_3.isc_7 == PYXIS__KEY_ENTER) {
			if (				/*X.WIDTH.STATE */
				   isc_3.isc_10 == PYXIS_OPT_USER_DATA)
				REPLACE_ATTRIBUTE(form, att_width, attype_numeric,	/*X.WIDTH */
								  isc_3.isc_5);
			if (				/*X.HEIGHT.STATE */
				   isc_3.isc_9 == PYXIS_OPT_USER_DATA)
				REPLACE_ATTRIBUTE(form, att_height, attype_numeric,	/*X.HEIGHT */
								  isc_3.isc_4);
			if (				/*X.OUTLINE_FORM.STATE */
				   isc_3.isc_8 == PYXIS_OPT_USER_DATA)
				if (			/*X.OUTLINE_FORM */
					   isc_3.isc_11[0] == 'Y') {
					REPLACE_ATTRIBUTE(form, att_box, attype_numeric, TRUE);
					REPLACE_ATTRIBUTE(form, att_border, attype_numeric, TRUE);
				}
				else {
					PYXIS_delete_named_attribute(form, att_box);
					PYXIS_delete_named_attribute(form, att_border);
				}
		}
/*END_FORM*/
		isc_pop_window((long *) 0L, &isc_window);
	};
}

static validate_name(string)
	 UCHAR *string;
{
/**************************************
 *
 *      v a l i d a t e _ n a m e
 *
 **************************************
 *
 * Functional description
 *      Validate a file and/or form name.
 *
 **************************************/

	for (; *string; string++)
		if (*string == ' ' || *string == '\t')
			return FALSE;

	return TRUE;
}
