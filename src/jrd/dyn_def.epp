/*
 *	PROGRAM:	JRD Data Definition Utility
 *	MODULE:		dyn_define.epp
 *	DESCRIPTION:	Dynamic data definition DYN_define_<x>
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * 23-May-2001 Claudio Valderrama - Forbid zero length identifiers,
 *                                   they are not ANSI SQL compliant.
 * 2001.10.08 Claudio Valderrama: Add case isc_dyn_system_flag to
 *	DYN_define_trigger() in order to receive values for special triggers
 *	as defined in constants.h.
 * 2001.10.08 Ann Harrison: Changed dyn_create_index so it doesn't consider
 *	simple unique indexes when finding a "referred index", but only
 * 	indexes that support unique constraints or primary keys.
 * 26-Sep-2001 Paul Beach - External File Directory Config. Parameter
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 * 2002.08.10 Dmitry Yemanov: ALTER VIEW
 *
 * 2002.10.29 Sean Leyne - Removed obsolete "Netware" port
 *
 * 2004.01.16 Vlad Horsun: added support for default parameters
 */

#include "firebird.h"
#include "dyn_consts.h"
#include "../common/classes/fb_string.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "../common/common.h"
#include "../jrd/jrd.h"
#include "../jrd/ods.h"
#include "../jrd/tra.h"
#include "../jrd/scl.h"
#include "../jrd/drq.h"
#include "../jrd/req.h"
#include "../jrd/flags.h"
#include "../jrd/ibase.h"
#include "../jrd/lls.h"
#include "../jrd/met.h"
#include "../jrd/btr.h"
#include "../jrd/ini.h"
#include "../jrd/intl.h"
#include "../jrd/dyn.h"
#include "../common/gdsassert.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dyn_proto.h"
#include "../jrd/dyn_df_proto.h"
#include "../jrd/dyn_ut_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/inf_proto.h"
#include "../jrd/intl_proto.h"
#include "../common/isc_f_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/vio_proto.h"
#include "../jrd/scl_proto.h"
#include "../common/gdsassert.h"
#include "../common/os/path_utils.h"
#include "../common/utils_proto.h"
#include "../jrd/IntlManager.h"
#include "../common/IntlUtil.h"
#include "../dsql/DdlNodes.h"

using MsgFormat::SafeArg;

using namespace Jrd;
using namespace Firebird;


DATABASE DB = STATIC "ODS.RDB";


void DYN_define_filter( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ d e f i n e _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *	Define a blob filter.
 *
 **************************************/

	thread_db* tdbb = JRD_get_thread_data();

	Firebird::MetaName filter_name;
	GET_STRING(ptr, filter_name);

	AutoCacheRequest request(tdbb, drq_s_filters, DYN_REQUESTS);

	bool b_ending_store = false;

	try {

		STORE(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$FILTERS USING
			strcpy(X.RDB$FUNCTION_NAME, filter_name.c_str());
			X.RDB$OUTPUT_SUB_TYPE.NULL = TRUE;
			X.RDB$INPUT_SUB_TYPE.NULL = TRUE;
			X.RDB$MODULE_NAME.NULL = TRUE;
			X.RDB$ENTRYPOINT.NULL = TRUE;
			X.RDB$SYSTEM_FLAG = 0;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;
		{
			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
			{
				switch (verb)
				{
				case isc_dyn_filter_in_subtype:
					X.RDB$INPUT_SUB_TYPE = (SSHORT)DYN_get_number(ptr);
					X.RDB$INPUT_SUB_TYPE.NULL = FALSE;
					break;

				case isc_dyn_filter_out_subtype:
					X.RDB$OUTPUT_SUB_TYPE = (SSHORT)DYN_get_number(ptr);
					X.RDB$OUTPUT_SUB_TYPE.NULL = FALSE;
					break;

				case isc_dyn_func_module_name:
					GET_STRING(ptr, X.RDB$MODULE_NAME);
					X.RDB$MODULE_NAME.NULL = FALSE;
					break;

				case isc_dyn_func_entry_point:
					GET_STRING(ptr, X.RDB$ENTRYPOINT);
					X.RDB$ENTRYPOINT.NULL = FALSE;
					break;

				default:
					DYN_unsupported_verb();
				}
			}
		}
		END_STORE
	}
	catch (const Firebird::Exception& ex)
	{
		Firebird::stuff_exception(tdbb->tdbb_status_vector, ex);
		if (b_ending_store)
		{
			DYN_error_punt(true, 7);
			// msg 7: "DEFINE BLOB FILTER failed"
		}
		throw;
	}
}


void DYN_define_index(Global* gbl, const UCHAR** ptr, const Firebird::MetaName* relation_name)
{
/**************************************
 *
 *	D Y N _ d e f i n e _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement that creates an index.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	const UCHAR index_type = isc_dyn_def_idx;
	Firebird::MetaName index_name;
	UCHAR verb;
	Firebird::MetaName trigger_name;

	GET_STRING(ptr, index_name);

	if (index_name.isEmpty())
		DYN_UTIL_generate_index_name(tdbb, gbl->gbl_transaction, index_name, index_type);

	DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_BEFORE,
		DDL_TRIGGER_CREATE_INDEX, index_name, gbl->sqlText);

	try
	{
		DYN_UTIL_check_unique_name(tdbb, gbl->gbl_transaction, index_name, obj_index);
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 21);	// msg 21: "STORE RDB$INDICES failed"
	}

	try
	{
		CreateIndexNode::Definition definition;
		definition.type = index_type;

		if (relation_name)
			definition.relation = *relation_name;
		else if (*(*ptr)++ == isc_dyn_rel_name)
			GET_STRING(ptr, definition.relation);
		else
			DYN_error_punt(false, 14);	// msg 14: "No relation specified for index"

		while ((verb = *(*ptr)++) != isc_dyn_end)
		{
			switch (verb)
			{
				case isc_dyn_idx_unique:
					definition.unique = bool(DYN_get_number(ptr));
					break;

				case isc_dyn_idx_inactive:
					definition.inactive = bool(DYN_get_number(ptr));
					break;

				case isc_dyn_idx_type:
					definition.descending = bool(DYN_get_number(ptr));
					break;

				case isc_dyn_fld_name:
				{
					MetaName& str = definition.columns.add();
					GET_STRING(ptr, str);
					break;
				}

				case isc_dyn_fld_computed_blr:
					DYN_put_blr_blob(gbl, ptr, &definition.expressionBlr);
					break;

				case isc_dyn_fld_computed_source:
					DYN_put_text_blob(gbl, ptr, &definition.expressionSource);
					break;

				default:
					DYN_unsupported_verb();
			}
		}

		CreateIndexNode::store(tdbb, gbl->gbl_transaction, index_name, definition);
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		throw;
	}

	DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_AFTER,
		DDL_TRIGGER_CREATE_INDEX, index_name, gbl->sqlText);
}
