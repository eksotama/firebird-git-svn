/*
 *	PROGRAM:	JRD Data Definition Utility
 *	MODULE:		dyn.epp
 *	DESCRIPTION:	Dynamic data definition
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 *    2001.04.20 Claudio Valderrama: Fix bug in grant/revoke by making user
 *                                      case insensitive.
 *    2001.05.24 Claudio Valderrama: Move DYN_delete_role to dyn_del.e.
 *    2001.06.05 John Bellardo: Renamed the revoke static function to
 *                                revoke_permission, because there is already
 *                                a revoke(2) function in *nix.
 *    2001.06.20 Claudio Valderrama: Enable calls to DYN_delete_generator.
 *    2001.10.01 Claudio Valderrama: Enable explicit GRANT...to ROLE role_name.
 *			and complain if the grantee ROLE doesn't exist.
 *    2001.10.06 Claudio Valderrama: Forbid "NONE" from role-related operations.
 *				Honor explicit USER keyword in GRANTs and REVOKEs. *
 *    2002.08.10 Dmitry Yemanov: ALTER VIEW
 *    2002.10.29 Nickolay Samofatov: Added support for savepoints
 *
 *	Alex Peshkov
 */

#include "firebird.h"
#include "dyn_consts.h"
#include <stdio.h>
#include <string.h>

#include "../common/common.h"
#include "../dsql/DdlNodes.h"
#include "../jrd/jrd.h"
#include "../jrd/ods.h"
#include "../jrd/tra.h"
#include "../jrd/dfw_proto.h"
#include "../jrd/UserManagement.h"
#include "../jrd/scl.h"
#include "../jrd/drq.h"
#include "../jrd/flags.h"
#include "../jrd/ibase.h"
#include "../jrd/lls.h"
#include "../jrd/met.h"
#include "../jrd/btr.h"
#include "../jrd/intl.h"
#include "../jrd/dyn.h"
//#include "../jrd/license.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dpm_proto.h"
#include "../jrd/dyn_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/inf_proto.h"
#include "../jrd/intl_proto.h"
#include "../common/isc_f_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/vio_proto.h"
#include "../jrd/thread_proto.h"
#include "../common/utils_proto.h"
#include "../utilities/gsec/gsec.h"
#include "../jrd/msg_encode.h"

using MsgFormat::SafeArg;


DATABASE DB = STATIC "ODS.RDB";

using namespace Jrd;
using namespace Firebird;


static void grant(Global*, const UCHAR**);
static bool grantor_can_grant(Global*, const TEXT*, const TEXT*, const MetaName&,
	const MetaName&, bool);
static bool grantor_can_grant_role(thread_db*, Global*, const MetaName&, const MetaName&);
static const char* privilege_name(char symbol);
static void	revoke_permission(Global*, const UCHAR**);
static void revoke_all(Global*, const UCHAR**);
static void store_privilege(Global*, const MetaName&, const MetaName&, const MetaName&,
	const TEXT*, SSHORT, SSHORT, int, const MetaName&);
static void	set_field_class_name(Global*, const MetaName&, const MetaName&);


void DYN_ddl(jrd_tra* transaction, ULONG length, const UCHAR* ddl, const string& sqlText)
{
/**************************************
 *
 *	D Y N _ d d l
 *
 **************************************
 *
 * Functional description
 *	Do meta-data.
 *
 **************************************/

	if (!transaction)
		status_exception::raise(Arg::Gds(isc_segstr_wrong_db));

	thread_db* const tdbb = JRD_get_thread_data();
	Jrd::Attachment* attachment = tdbb->getAttachment();

	const UCHAR* ptr = ddl;

	if (*ptr++ != isc_dyn_version_1)
		ERR_post(Arg::Gds(isc_wrodynver));

	fb_utils::init_status(tdbb->tdbb_status_vector);

	Global gbl(transaction, sqlText);

	// Create a pool for DYN to operate in.  It will be released when
	// the routine exits.
	MemoryPool* const tempPool = attachment->createPool();
	Jrd::ContextPoolHolder context(tdbb, tempPool);

	try
	{
		VIO_start_save_point(tdbb, transaction);
		transaction->tra_save_point->sav_verb_count++;

		DYN_execute(&gbl, &ptr, NULL, NULL, NULL, NULL, NULL);
		transaction->tra_save_point->sav_verb_count--;
		VIO_verb_cleanup(tdbb, transaction);
		fb_assert(ptr <= ddl + length); // disaster check after it happened
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		const Savepoint* savepoint = transaction->tra_save_point;
		if (savepoint && savepoint->sav_verb_count)
		{
			// An error during undo is very bad and has to be dealt with
			// by aborting the transaction.  The easiest way is to kill
			// the application by calling bugcheck.

			try {
				VIO_verb_cleanup(tdbb, transaction);
			}
			catch (const Exception&) {
				BUGCHECK(290);	// msg 290 error during savepoint backout
			}
		}

		attachment->deletePool(tempPool);

		ERR_punt();
	}

	attachment->deletePool(tempPool);
}


void DYN_error(bool	status_flag, USHORT number, const SafeArg& sarg)
{
/**************************************
 *
 *	D Y N _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	DDL failed.
 *
 **************************************/
	thread_db* const tdbb = JRD_get_thread_data();

	if (tdbb->tdbb_status_vector[1] == isc_no_meta_update)
		return;

	TEXT error_buffer[BUFFER_MEDIUM];
	Arg::Gds local_status(isc_no_meta_update);

	if (number)
	{
		fb_msg_format(NULL, DYN_MSG_FAC, number, sizeof(error_buffer), error_buffer, sarg);

		ISC_STATUS_ARRAY temp_status;
		fb_utils::init_status(temp_status);
		temp_status[1] = ENCODE_ISC_MSG(number, DYN_MSG_FAC);
		FB_SQLSTATE_STRING sqlstate;
		fb_sqlstate(sqlstate, temp_status);
		if (!strcmp(sqlstate, "HY000"))
			strcpy(sqlstate, "42000"); // default SQLSTATE for DYN

		local_status << Arg::Gds(isc_random) << Arg::Str(error_buffer) << Arg::SqlState(sqlstate);
	}
	ERR_make_permanent(local_status);
	if (status_flag) {
		local_status.append(Arg::StatusVector(tdbb->tdbb_status_vector));
	}

	local_status.copyTo(tdbb->tdbb_status_vector);
}


void DYN_error_punt(bool status_flag, USHORT number, const SafeArg& arg)
{
/**************************************
 *
 *	D Y N _ e r r o r _ p u n t
 *
 **************************************
 *
 * Functional description
 *	DDL failed.
 *
 **************************************/

	DYN_error(status_flag, number, arg);
	ERR_punt();
}


void DYN_error_punt(bool status_flag, USHORT number, const char* str)
{
/**************************************
 *
 *	D Y N _ e r r o r _ p u n t
 *
 **************************************
 *
 * Functional description
 *	DDL failed.
 *
 **************************************/

	DYN_error(status_flag, number, SafeArg() << str);
	ERR_punt();
}


void DYN_error_punt(bool status_flag, USHORT number)
{
/**************************************
 *
 *	D Y N _ e r r o r _ p u n t
 *
 **************************************
 *
 * Functional description
 *	DDL failed.
 *
 **************************************/

	static const SafeArg dummy;
	DYN_error(status_flag, number, dummy);
	ERR_punt();
}


bool DYN_is_it_sql_role(jrd_tra* transaction,
						const MetaName&	input_name,
						MetaName& output_name,
						thread_db* tdbb)
{
/**************************************
 *
 *	D Y N _ i s _ i t _ s q l _ r o l e
 *
 **************************************
 *
 * Functional description
 *
 *	If input_name is found in RDB$ROLES, then returns true. Otherwise
 *    returns false.
 *
 **************************************/
	SET_TDBB(tdbb);

	bool found = false;

	AutoCacheRequest request(tdbb, drq_get_role_nm, DYN_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		X IN RDB$ROLES WITH
			X.RDB$ROLE_NAME EQ input_name.c_str()
	{
		found = true;
		output_name = X.RDB$OWNER_NAME;
	}
	END_FOR

	return found;
}


void DYN_unsupported_verb()
{
/**************************************
 *
 *	D Y N _ u n s u p p o r t e d _ v e r b
 *
 **************************************
 *
 * Functional description
 *	We encountered an unsupported dyn verb.
 *
 **************************************/

	static const SafeArg dummy;
	DYN_error_punt(false, 2, dummy);	// msg 2: "unsupported DYN verb"
}


void DYN_execute(Global* gbl,
				 const UCHAR** ptr,
				 const MetaName* relation_name,
				 MetaName* field_name,
				 MetaName* trigger_name,
				 MetaName* function_name,
				 MetaName* procedure_name)
{
/**************************************
 *
 *	D Y N _ e x e c u t e
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement.
 *
 **************************************/
	UCHAR verb;

	switch (verb = *(*ptr)++)
	{
	case isc_dyn_begin:
		while (**ptr != isc_dyn_end)
		{
			DYN_execute(gbl, ptr, relation_name, field_name,
						trigger_name, function_name, procedure_name);
		}
		++(*ptr);
		break;

		// Runtime security-related dynamic DDL should not require licensing.
		// A placeholder case statement for SQL 3 Roles is reserved below.

	case isc_dyn_grant:
		grant(gbl, ptr);
		break;

	case isc_dyn_revoke:
		revoke_permission(gbl, ptr);
		break;

	case isc_dyn_revoke_all:
		revoke_all(gbl, ptr);
		break;

	default:
		DYN_unsupported_verb();
		break;
	}
}


SLONG DYN_get_number(const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ g e t _ n u m b e r
 *
 **************************************
 *
 * Functional description
 *	Pick up a number and possible clear a null flag.
 *
 **************************************/
	const UCHAR* p = *ptr;
	USHORT length = *p++;
	length |= (*p++) << 8;
	*ptr = p + length;

	return gds__vax_integer(p, length);
}


USHORT DYN_get_string(const UCHAR** ptr, TEXT* field, size_t size)
{
/**************************************
 *
 *	D Y N _ g e t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Pick up a string, move to a target, and, if requested,
 *	set a null flag.  Return length of string.
 *	If destination field size is too small, punt.
 *	Strings need enough space for null pad.
 *
 **************************************/
	const UCHAR* p = *ptr;
	USHORT length = *p++;
	length |= ((USHORT) *p++) << 8;

	if (length >= size) {
		DYN_error_punt(false, 159); // msg 159: Name longer than database field size
	}

	memcpy(field, p, length);
	field[length] = 0;
	p += length;

	*ptr = p;

	return length;
}


USHORT DYN_get_string(const UCHAR** ptr, MetaName& field, size_t)
{
/**************************************
 *
 *	D Y N _ g e t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Pick up an object name, move to a target. Return length of string.
 *	If destination field size is too small, punt.
 *
 **************************************/
	const UCHAR* p = *ptr;
	USHORT length = *p++;
	length |= ((USHORT) *p++) << 8;

	if (length > MAX_SQL_IDENTIFIER_LEN)
	{
		DYN_error_punt(false, 159);
		// msg 159: Name longer than database field size
	}
	field.assign(reinterpret_cast<const char*>(p), length);
	p += length;

	*ptr = p;

	return length;
}


USHORT DYN_get_string(const UCHAR** ptr, string& field, size_t)
{
/**************************************
 *
 *	D Y N _ g e t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Pick up an object name, move to a target. Return length of string.
 *	If destination field size is too small, punt.
 *
 **************************************/
	const UCHAR* p = *ptr;
	USHORT length = *p++;
	length |= ((USHORT) *p++) << 8;

	if (length > MAX_SQL_IDENTIFIER_LEN)
	{
		DYN_error_punt(false, 159);
		// msg 159: Name longer than database field size
	}
	field.assign(reinterpret_cast<const char*>(p), length);
	p += length;

	*ptr = p;

	return length;
}


USHORT DYN_get_string(const UCHAR** ptr, PathName& field, size_t)
{
/**************************************
 *
 *	D Y N _ g e t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Pick up a file name, move to a target. Return length
 *	of string.
 *
 **************************************/
	const UCHAR* p = *ptr;
	USHORT length = *p++;
	length |= ((USHORT) *p++) << 8;

	field.assign(reinterpret_cast<const char*>(p), length);
	p += length;

	*ptr = p;

	return length;
}


USHORT DYN_get_string(const UCHAR** ptr, UCharBuffer& array, size_t)
{
/**************************************
 *
 *	D Y N _ g e t _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Pick up a string, move to a target. Return length
 *	of string.
 *
 **************************************/
	const UCHAR* p = *ptr;
	USHORT length = *p++;
	length |= ((USHORT) *p++) << 8;

	memcpy(array.getBuffer(length), p, length);

	p += length;
	*ptr = p;

	return length;
}


static void grant( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	g r a n t
 *
 **************************************
 *
 * Functional description
 *	Execute SQL grant operation.
 *
 **************************************/

	SSHORT id;
	char privileges[16];
	MetaName object;
	MetaName field;
	MetaName user;
	TEXT priv[2];
	bool grant_role_stmt = false;

	thread_db* tdbb = JRD_get_thread_data();
	MetaName grantor = tdbb->getAttachment()->att_user->usr_user_name;

	GET_STRING(ptr, privileges);
	if (!strcmp(privileges, "A")) {
		strcpy(privileges, ALL_PRIVILEGES);
	}

	int    options   = 0;
	SSHORT user_type = -1;
	SSHORT obj_type  = -1;
    MetaName dummy_name;

	UCHAR verb;
	while ((verb = *(*ptr)++) != isc_dyn_end)
	{
		switch (verb)
		{
		case isc_dyn_rel_name:
			obj_type = obj_relation;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_prc_name:
			obj_type = obj_procedure;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_fun_name:
			obj_type = obj_udf;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_pkg_name:
			obj_type = obj_package_header;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_fld_name:
			GET_STRING(ptr, field);
			break;

		case isc_dyn_grant_user_group:
			user_type = obj_user_group;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_user:
			GET_STRING(ptr, user);
			// This test may become obsolete as we now allow explicit ROLE keyword.
			if (DYN_is_it_sql_role(gbl->gbl_transaction, user, dummy_name, tdbb))
			{
				user_type = obj_sql_role;
				if (user == NULL_ROLE)
				{
					DYN_error_punt(false, 195, user.c_str());
					// msg 195: keyword NONE could not be used as SQL role name.
				}
			}
			else
			{
				user_type = obj_user;
				user.upper7();
			}
			break;

		case isc_dyn_grant_user_explicit:
		    GET_STRING(ptr, user);
			user_type = obj_user;
			user.upper7();
		    break;

		case isc_dyn_grant_role:
		    user_type = obj_sql_role;
		    GET_STRING(ptr, user);
			if (!DYN_is_it_sql_role(gbl->gbl_transaction, user, dummy_name, tdbb))
			{
				DYN_error_punt(false, 188, user.c_str());
				// msg 188: Role doesn't exist.
			}
			if (user == NULL_ROLE)
			{
				DYN_error_punt(false, 195, user.c_str());
				// msg 195: keyword NONE could not be used as SQL role name.
			}
			break;

		case isc_dyn_sql_role_name:	// role name in role_name_list
			obj_type = obj_sql_role;
			GET_STRING(ptr, object);
			grant_role_stmt = true;
			if (object == NULL_ROLE)
			{
				DYN_error_punt(false, 195, object.c_str());
				// msg 195: keyword NONE could not be used as SQL role name.
			}
			break;

		case isc_dyn_grant_package:
			user_type = obj_package_header;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_proc:
			user_type = obj_procedure;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_func:
			user_type = obj_udf;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_trig:
			user_type = obj_trigger;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_view:
			user_type = obj_view;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_options:
		case isc_dyn_grant_admin_options:
			options = DYN_get_number(ptr);
			break;

		case isc_dyn_grant_grantor:
			if (! tdbb->getAttachment()->locksmith())
			{
				DYN_error_punt(false, 252, SYSDBA_USER_NAME);
			}
			GET_STRING(ptr, grantor);
			break;

		default:
			DYN_unsupported_verb();
		}
	}
	grantor.upper7();

	try {

	AutoCacheRequest request(tdbb, (field.length() > 0 ? drq_l_grant1 : drq_l_grant2), DYN_REQUESTS);

	for (const TEXT* pr = privileges; *pr; pr++)
	{
		bool duplicate = false;
		priv[0] = *pr;
		priv[1] = 0;
		if (field.length() > 0)
		{
			id = drq_l_grant1;
			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				PRIV IN RDB$USER_PRIVILEGES WITH
					PRIV.RDB$RELATION_NAME EQ object.c_str() AND
					PRIV.RDB$OBJECT_TYPE = obj_type AND
					PRIV.RDB$PRIVILEGE EQ priv AND
					PRIV.RDB$USER = user.c_str() AND
					PRIV.RDB$USER_TYPE = user_type AND
					PRIV.RDB$GRANTOR EQ grantor.c_str() AND
					PRIV.RDB$FIELD_NAME EQ field.c_str()
			{
				if ((PRIV.RDB$GRANT_OPTION.NULL) ||
					(PRIV.RDB$GRANT_OPTION) ||
					(PRIV.RDB$GRANT_OPTION == options))
				{
					duplicate = true;
				}
				else
				{
					ERASE PRIV;	// has to be 0 and options == 1
				}
			}
			END_FOR
		}
		else
		{
			id = drq_l_grant2;
			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				PRIV IN RDB$USER_PRIVILEGES WITH
					PRIV.RDB$RELATION_NAME EQ object.c_str() AND
					PRIV.RDB$OBJECT_TYPE = obj_type AND
					PRIV.RDB$PRIVILEGE EQ priv AND
					PRIV.RDB$USER = user.c_str() AND
					PRIV.RDB$USER_TYPE = user_type AND
					PRIV.RDB$GRANTOR EQ grantor.c_str() AND
					PRIV.RDB$FIELD_NAME MISSING
			{
				if ((PRIV.RDB$GRANT_OPTION.NULL) ||
					(PRIV.RDB$GRANT_OPTION) ||
					(PRIV.RDB$GRANT_OPTION == options))
				{
					duplicate = true;
				}
				else
				{
					ERASE PRIV;	// has to be 0 and options == 1
				}
			}
			END_FOR
		}

		if (duplicate) {
			continue;
		}

		if (grant_role_stmt)
		{
			id = drq_get_role_nm;

			if (!grantor_can_grant_role(tdbb, gbl, grantor, object))
			{
				// ERR_punt();
				goto do_punt;
			}

			if (user_type == obj_sql_role)
			{
				/****************************************************
	            **
	            ** temporary restriction. This should be removed once
	            ** GRANT role1 TO rolex is supported and this message
	            ** could be reused for blocking cycles of role grants
	            **
	            *****************************************************/
	            DYN_error_punt(false, 192, user.c_str());
			}
		}
		else
		{
			/* In the case where the object is a view, then the grantor must have
			   some kind of grant privileges on the base table(s)/view(s).  If the
			   grantor is the owner of the view, then we have to explicitely check
			   this because the owner of a view by default has grant privileges on
			   his own view.  If the grantor is not the owner of the view, then the
			   base table/view grant privilege checks were made when the grantor
			   got its grant privilege on the view and no further checks are
			   necessary.
			   As long as only locksmith can use GRANTED BY, no need specially checking
			   for privileges of current user. AP-2008 */

			if (!obj_type)
			{
				// relation or view because we cannot distinguish at this point.
				id = drq_gcg1;
				if (!grantor_can_grant(gbl,
										tdbb->getAttachment()->att_user->usr_user_name.c_str(),
										priv,
										object,
										field,
										true))
				{
					// grantor_can_grant has moved the error string already.
					// just punt back to the setjump
					// ERR_punt();
					goto do_punt;
				}
			}
		}

		id = drq_s_grant;
		store_privilege(gbl, object, user, field, pr, user_type, obj_type, options, grantor);
	}	// for (...)

	}	// try
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);

		switch (id)
		{
		case drq_l_grant1:
			DYN_error_punt(true, 77);
			// msg 77: "SELECT RDB$USER_PRIVILEGES failed in grant"
			break;
		case drq_l_grant2:
			DYN_error_punt(true, 78);
			// msg 78: "SELECT RDB$USER_PRIVILEGES failed in grant"
			break;
		case drq_s_grant:
		case drq_gcg1:
			ERR_punt();
			// store_priviledge || grantor_can_grant error already handled,
			// just bail out
			break;
		case drq_get_role_nm:
			ERR_punt();
			break;
		default:
			fb_assert(id == drq_gcg1);
			DYN_error_punt(true, 78);
			// msg 78: "SELECT RDB$USER_PRIVILEGES failed in grant"
			break;
		}
	}

	return;

do_punt:	// ugly, rethink logic of this function
	ERR_punt();
}


static bool grantor_can_grant(Global* gbl,
							  const TEXT* grantor,
							  const TEXT* privilege,
							  const MetaName& relation_name,
							  const MetaName& field_name,
							  bool top_level)
{
/**************************************
 *
 *	g r a n t o r _ c a n _ g r a n t
 *
 **************************************
 *
 * Functional description
 *	return: true is the grantor has grant privilege on the relation/field.
 *		false otherwise.
 *
 **************************************/
	USHORT err_num;

	thread_db* tdbb = JRD_get_thread_data();

	// Verify that the input relation exists.

	AutoCacheRequest request(tdbb, drq_gcg4, DYN_REQUESTS);

	try {

	err_num = 182;				// for the longjump
	bool sql_relation = false;
	bool relation_exists = false;
	// SELECT RDB$RELATIONS failed in grant
	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		REL IN RDB$RELATIONS WITH
			REL.RDB$RELATION_NAME = relation_name.c_str()
	{
		relation_exists = true;
		if ((!REL.RDB$FLAGS.NULL) && (REL.RDB$FLAGS & REL_sql))
			sql_relation = true;
	}
	END_FOR

	if (!relation_exists)
	{
		DYN_error(false, 175, SafeArg() << relation_name.c_str());
		// table/view .. does not exist
		return false;
	}

	// Verify the the input field exists.

	if (field_name.length() > 0)
	{
		err_num = 183;
		bool field_exists = false;

		// SELECT RDB$RELATION_FIELDS failed in grant
		request.reset(tdbb, drq_gcg5, DYN_REQUESTS);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			G_FLD IN RDB$RELATION_FIELDS WITH
				G_FLD.RDB$RELATION_NAME = relation_name.c_str() AND
				G_FLD.RDB$FIELD_NAME = field_name.c_str()
		{
			field_exists = true;
		}
		END_FOR

		if (!field_exists)
		{
			DYN_error(false, 176, SafeArg() << field_name.c_str() << relation_name.c_str());
			// column .. does not exist in table/view ..
			return false;
		}
	}

	// If the current user is locksmith - allow all grants to occur

	if (tdbb->getAttachment()->locksmith()) {
		return true;
	}

	// If this is a non-sql table, then the owner will probably not have any
	// entries in the rdb$user_privileges table.  Give the owner of a GDML
	// table all privileges.
	err_num = 184;
	bool grantor_is_owner = false;
	// SELECT RDB$RELATIONS/RDB$OWNER_NAME failed in grant

	request.reset(tdbb, drq_gcg2, DYN_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		REL IN RDB$RELATIONS WITH
			REL.RDB$RELATION_NAME = relation_name.c_str() AND
			REL.RDB$OWNER_NAME = UPPERCASE(grantor)
	{
		grantor_is_owner = true;
	}
	END_FOR

	if (!sql_relation && grantor_is_owner)
		return true;

	// Remember the grant option for non field-specific user-privileges, and
	// the grant option for the user-privileges for the input field.
	// -1 = no privilege found (yet)
	// 0 = privilege without grant option found
	// 1 = privilege with grant option found
	SSHORT go_rel = -1;
	SSHORT go_fld = -1;

	// Verify that the grantor has the grant option for this relation/field
	// in the rdb$user_privileges.  If not, then we don't need to look further.

	err_num = 185;
	// SELECT RDB$USER_PRIVILEGES failed in grant

	request.reset(tdbb, drq_gcg1, DYN_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		PRV IN RDB$USER_PRIVILEGES WITH
			PRV.RDB$USER = UPPERCASE(grantor) AND
			PRV.RDB$USER_TYPE = obj_user AND
			PRV.RDB$RELATION_NAME = relation_name.c_str() AND
			PRV.RDB$OBJECT_TYPE = obj_relation AND
			PRV.RDB$PRIVILEGE = privilege
	{
		if (PRV.RDB$FIELD_NAME.NULL)
		{
			if (PRV.RDB$GRANT_OPTION.NULL || !PRV.RDB$GRANT_OPTION)
				go_rel = 0;
			else if (go_rel)
				go_rel = 1;
		}
		else
		{
			if (PRV.RDB$GRANT_OPTION.NULL || !PRV.RDB$GRANT_OPTION)
			{
				if (field_name.length() && field_name == PRV.RDB$FIELD_NAME)
					go_fld = 0;
			}
			else
			{
				if (field_name.length() && field_name == PRV.RDB$FIELD_NAME)
					go_fld = 1;
			}
		}
	}
	END_FOR

	if (field_name.length())
	{
		if (go_fld == 0)
		{
			DYN_error(false,
					(USHORT)(top_level ? 167 : 168),
					SafeArg() << privilege << field_name.c_str() << relation_name.c_str());
			// no grant option for privilege .. on column .. of [base] table/view ..
			return false;
		}

		if (go_fld == -1)
		{
			if (go_rel == 0)
			{
				DYN_error(false,
						(USHORT)(top_level ? 169 : 170),
						SafeArg() << privilege << relation_name.c_str() << field_name.c_str());
				// no grant option for privilege .. on [base] table/view .. (for column ..)
				return false;
			}

			if (go_rel == -1)
			{
				DYN_error(false,
						(USHORT)(top_level ? 171 : 172),
						SafeArg() << privilege << relation_name.c_str() << field_name.c_str());
				// no .. privilege with grant option on [base] table/view .. (for column ..)
				return false;
			}
		}
	}
	else
	{
		if (go_rel == 0)
		{
			DYN_error(false, 173, SafeArg() << privilege << relation_name.c_str());
			// no grant option for privilege .. on table/view ..
			return false;
		}

		if (go_rel == -1)
		{
			DYN_error(false, 174, SafeArg() << privilege << relation_name.c_str());
			// no .. privilege with grant option on table/view ..
			return false;
		}
	}

	// If the grantor is not the owner of the relation, then we don't need to
	// check the base table(s)/view(s) because that check was performed when
	// the grantor was given its privileges.

	if (!grantor_is_owner) {
		return true;
	}

	// Find all the base fields/relations and check for the correct grant privileges on them.

	err_num = 186;
	// SELECT RDB$VIEW_RELATIONS/RDB$RELATION_FIELDS/... failed in grant

	request.reset(tdbb, drq_gcg3, DYN_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		G_FLD IN RDB$RELATION_FIELDS CROSS
			G_VIEW IN RDB$VIEW_RELATIONS WITH
			G_FLD.RDB$RELATION_NAME = relation_name.c_str() AND
			G_FLD.RDB$BASE_FIELD NOT MISSING AND
			G_VIEW.RDB$VIEW_NAME EQ G_FLD.RDB$RELATION_NAME AND
			G_VIEW.RDB$VIEW_CONTEXT EQ G_FLD.RDB$VIEW_CONTEXT
	{
		if (field_name.length())
		{
			if (field_name == G_FLD.RDB$FIELD_NAME)
				if (!grantor_can_grant(gbl, grantor, privilege, G_VIEW.RDB$RELATION_NAME,
										G_FLD.RDB$BASE_FIELD, false))
				{
					return false;
				}
		}
		else
		{
			if (!grantor_can_grant(gbl, grantor, privilege, G_VIEW.RDB$RELATION_NAME,
									G_FLD.RDB$BASE_FIELD, false))
			{
				return false;
			}
		}
	}
	END_FOR

	// all done.

	}	// try
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, err_num);
		// msg 77: "SELECT RDB$USER_PRIVILEGES failed in grant"

		return false;
	}

	return true;
}


static bool grantor_can_grant_role(thread_db* tdbb,
								   Global* gbl,
								   const MetaName& grantor,
								   const MetaName& role_name)
{
/**************************************
 *
 *	g r a n t o r _ c a n _ g r a n t _ r o l e
 *
 **************************************
 *
 * Functional description
 *
 *	return: true if the grantor has admin privilege on the role.
 *		false otherwise.
 *
 **************************************/

	bool grantable = false;
	bool no_admin = false;

	SET_TDBB(tdbb);

	// Fetch the name of the owner of the ROLE
	MetaName owner;
	if (DYN_is_it_sql_role(gbl->gbl_transaction, role_name, owner, tdbb))
	{
		// Both SYSDBA and the owner of this ROLE can grant membership
		if (tdbb->getAttachment()->locksmith() || owner == grantor)
			return true;
	}
	else
	{
		// role name not exist.
		DYN_error(false, 188, SafeArg() << role_name.c_str());
		return false;
	}

	AutoCacheRequest request(tdbb, drq_get_role_au, DYN_REQUESTS);

	// The 'grantor' is not the owner of the ROLE, see if they
	// have admin privilege on the role
	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		PRV IN RDB$USER_PRIVILEGES WITH
			PRV.RDB$USER = UPPERCASE(grantor.c_str()) AND
			PRV.RDB$USER_TYPE = obj_user AND
			PRV.RDB$RELATION_NAME EQ role_name.c_str() AND
			PRV.RDB$OBJECT_TYPE = obj_sql_role AND
			PRV.RDB$PRIVILEGE EQ "M"
	{
		if (PRV.RDB$GRANT_OPTION == 2)
			grantable = true;
		else
			no_admin = true;
	}
	END_FOR

	if (!grantable)
	{
		// 189: user have no admin option.
		// 190: user is not a member of the role.
		DYN_error(false, no_admin ? 189 : 190, SafeArg() << grantor.c_str() << role_name.c_str());
		return false;
	}

	return true;
}


static const char* privilege_name(char symbol)
{
/**************************************
 *
 *	p r i v i l e g e _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Diagnostics print helper.
 *
 **************************************/
	switch (UPPER7(symbol))
	{
		case 'A': return "All";
		case 'I': return "Insert";
		case 'U': return "Update";
		case 'D': return "Delete";
		case 'S': return "Select";
		case 'X': return "Execute";
		case 'M': return "Role";
		case 'R': return "Reference";
	}
	return "<Unknown>";
}


static void revoke_permission(Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	r e v o k e _ p e r m i s s i o n
 *
 **************************************
 *
 * Functional description
 *	Revoke some privileges.
 *
 *	Note: According to SQL II, section 11.37, pg 280,
 *	general rules 8 & 9,
 *	if the specified priviledge for the specified user
 *	does not exist, it is not an exception error condition
 *	but a completion condition.  Since V4.0 does not support
 *	completion conditions (warnings) we do not return
 *	any indication that the revoke operation didn't do
 *	anything.
 *	1994-August-2 Rich Damon & David Schnepper
 *
 **************************************/
	UCHAR verb;
	char privileges[16];
	MetaName object, field, user;
	MetaName dummy_name;

	thread_db* tdbb = JRD_get_thread_data();

	// Stash away a copy of the revoker's name, in uppercase form

	const UserId* revoking_user = tdbb->getAttachment()->att_user;
	MetaName revoking_as_user_name(revoking_user->usr_user_name);
	revoking_as_user_name.upper7();

	GET_STRING(ptr, privileges);
	if (!strcmp(privileges, "A")) {
		strcpy(privileges, ALL_PRIVILEGES);
	}

	int options = 0;
	SSHORT user_type = -1;
	SSHORT obj_type = -1;

	while ((verb = *(*ptr)++) != isc_dyn_end)
	{
		switch (verb)
		{
		case isc_dyn_rel_name:
			obj_type = obj_relation;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_prc_name:
			obj_type = obj_procedure;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_fun_name:
			obj_type = obj_udf;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_pkg_name:
			obj_type = obj_package_header;
			GET_STRING(ptr, object);
			break;

		case isc_dyn_fld_name:
			GET_STRING(ptr, field);
			break;

		case isc_dyn_grant_user_group:
			user_type = obj_user_group;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_user:
			GET_STRING(ptr, user);
			// This test may become obsolete as we now allow explicit ROLE keyword.
			if (DYN_is_it_sql_role(gbl->gbl_transaction, user, dummy_name, tdbb))
			{
				user_type = obj_sql_role;
				if (user == NULL_ROLE)
				{
					DYN_error_punt(false, 195, user.c_str());
					// msg 195: keyword NONE could not be used as SQL role name.
				}
			}
			else
			{
				user_type = obj_user;
				user.upper7();
			}
			break;

		case isc_dyn_grant_user_explicit:
		    GET_STRING(ptr, user);
	        user_type = obj_user;
			user.upper7();
			break;

		case isc_dyn_grant_role:
			user_type = obj_sql_role;
			GET_STRING(ptr, user);
			if (!DYN_is_it_sql_role(gbl->gbl_transaction, user, dummy_name, tdbb))
			{
				DYN_error_punt(false, 188, user.c_str());
				// msg 188: Role doesn't exist.
			}
			if (user == NULL_ROLE)
			{
				DYN_error_punt(false, 195, user.c_str());
				// msg 195: keyword NONE could not be used as SQL role name.
			}
		    break;

		case isc_dyn_sql_role_name:	// role name in role_name_list
			obj_type = obj_sql_role;
			GET_STRING(ptr, object);
/*
			CVC: Make this a warning in the future.
			if (object == NULL_ROLE)
				DYN_error_punt(false, 195, object.c_str());
*/
			// msg 195: keyword NONE could not be used as SQL role name.
			break;

		case isc_dyn_grant_package:
			user_type = obj_package_header;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_proc:
			user_type = obj_procedure;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_func:
			user_type = obj_udf;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_trig:
			user_type = obj_trigger;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_view:
			user_type = obj_view;
			GET_STRING(ptr, user);
			break;

		case isc_dyn_grant_options:
		case isc_dyn_grant_admin_options:
			options = DYN_get_number(ptr);
			break;

		case isc_dyn_grant_grantor:
			if (! tdbb->getAttachment()->locksmith())
			{
				DYN_error_punt(false, 252, SYSDBA_USER_NAME);
			}
			GET_STRING(ptr, revoking_as_user_name);
			break;

		default:
			DYN_unsupported_verb();
		}
	}
	revoking_as_user_name.upper7();


	USHORT id = field.length() ? drq_e_grant1 : drq_e_grant2;

	AutoCacheRequest request(tdbb, id, DYN_REQUESTS);

	try {

    TEXT temp[2];
	temp[1] = 0;
	for (const TEXT* pr = privileges; (temp[0] = *pr); pr++)
	{
		bool grant_erased = false;
		bool bad_grantor = false;

		if (field.length())
		{
			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				PRIV IN RDB$USER_PRIVILEGES WITH
					PRIV.RDB$PRIVILEGE EQ temp AND
					PRIV.RDB$RELATION_NAME EQ object.c_str() AND
					PRIV.RDB$OBJECT_TYPE = obj_type AND
					PRIV.RDB$USER = user.c_str() AND
					PRIV.RDB$USER_TYPE = user_type AND
					PRIV.RDB$FIELD_NAME EQ field.c_str()
			{
				if (revoking_as_user_name == PRIV.RDB$GRANTOR)
				{
					ERASE PRIV;
					grant_erased = true;
				}
				else
				{
					bad_grantor = true;
				}
			}
			END_FOR
		}
		else
		{
			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				PRIV IN RDB$USER_PRIVILEGES WITH
					PRIV.RDB$PRIVILEGE EQ temp AND
					PRIV.RDB$RELATION_NAME EQ object.c_str() AND
					PRIV.RDB$OBJECT_TYPE = obj_type AND
					PRIV.RDB$USER EQ user.c_str() AND
					PRIV.RDB$USER_TYPE = user_type
			{
				// revoking a permission at the table level implies
				// revoking the perm. on all columns. So for all fields
				// in this table which have been granted the privilege, we
				// erase the entries from RDB$USER_PRIVILEGES.

				if (revoking_as_user_name == PRIV.RDB$GRANTOR)
				{
					ERASE PRIV;
					grant_erased = true;
				}
				else
				{
					bad_grantor = true;
				}
			}
			END_FOR
		}

		if (options && grant_erased)
		{
			// Add the privilege without the grant option
			// There is a modify trigger on the rdb$user_privileges
			// which disallows the table from being updated.  It would
			// have to be changed such that only the grant_option
			// field can be updated.

			const USHORT old_id = id;
			id = drq_s_grant;

			store_privilege(gbl, object, user, field, pr, user_type, obj_type,
							0, revoking_as_user_name);

			id = old_id;
		}

		if (bad_grantor && !grant_erased)
		{
			DYN_error_punt(false, 246, SafeArg() << revoking_as_user_name.c_str() <<
				privilege_name(temp[0]) << object.c_str() << user.c_str());
			// msg 246: @1 is not grantor of @2 on @3 to @4.
		}

		if (!grant_erased)
		{
			ERR_post_warning(Arg::Warning(isc_dyn_miss_priv_warning) <<
							 Arg::Str(privilege_name(temp[0])) << Arg::Str(object) << Arg::Str(user));
			// msg 247: Warning: @1 on @2 is not granted to @3.
		}
	}

	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);

		if (id == drq_e_grant1)
		{
			DYN_error_punt(true, 111);
			// msg 111: "ERASE RDB$USER_PRIVILEGES failed in revoke(1)"
		}
		else if (id == drq_e_grant2)
		{
			DYN_error_punt(true, 113);
			// msg 113: "ERASE RDB$USER_PRIVILEGES failed in revoke (3)"
		}
		else
		{
			ERR_punt();
			// store_priviledge error already handled, just bail out
		}
	}
}


static void revoke_all(Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	r e v o k e _ a l l
 *
 **************************************
 *
 * Functional description
 *	Revoke all privileges on all objects from user/role.
 *
 **************************************/
	UCHAR verb;
	MetaName user, dummy_name;
	SSHORT user_type = -1;

	thread_db* tdbb = JRD_get_thread_data();

	while ((verb = *(*ptr)++) != isc_dyn_end)
	{
		switch (verb)
		{

		case isc_dyn_grant_user:
			GET_STRING(ptr, user);
			// This test may become obsolete as we now allow explicit ROLE keyword.
			if (DYN_is_it_sql_role(gbl->gbl_transaction, user, dummy_name, tdbb))
			{
				user_type = obj_sql_role;
				if (user == NULL_ROLE)
				{
					DYN_error_punt(false, 195, user.c_str());
					// msg 195: keyword NONE could not be used as SQL role name.
				}
			}
			else
			{
				user_type = obj_user;
				user.upper7();
			}
			break;

		case isc_dyn_grant_user_explicit:
		    GET_STRING(ptr, user);
	        user_type = obj_user;
			user.upper7();
			break;

		case isc_dyn_grant_role:
			GET_STRING(ptr, user);
			user_type = obj_sql_role;
			if (!DYN_is_it_sql_role(gbl->gbl_transaction, user, dummy_name, tdbb)) {
				DYN_error_punt(false, 188, user.c_str()); // msg 188: Role doesn't exist.
			}
			if (user == NULL_ROLE)
			{
				DYN_error_punt(false, 195, user.c_str());
				// msg 195: keyword NONE could not be used as SQL role name.
			}
		    break;

		default:
			DYN_unsupported_verb();
		}
	}

	const UserId* revoking_user = tdbb->getAttachment()->att_user;
	MetaName revoking_as_user_name(revoking_user->usr_user_name);
	revoking_as_user_name.upper7();

	bool grant_erased = false;
	bool bad_grantor = false;

	AutoCacheRequest request(tdbb, drq_e_grant3, DYN_REQUESTS);

	try {
		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			PRIV IN RDB$USER_PRIVILEGES WITH
				PRIV.RDB$USER = user.c_str() AND
				PRIV.RDB$USER_TYPE = user_type
		{
			if (revoking_user->locksmith() || revoking_as_user_name == PRIV.RDB$GRANTOR)
			{
				ERASE PRIV;
				grant_erased = true;
			}
			else
			{
				bad_grantor = true;
			}
		}
		END_FOR

		if (!grant_erased)
		{
			const char* all = "ALL";
			if (bad_grantor)
			{
				DYN_error_punt(false, 246, SafeArg() << revoking_as_user_name.c_str() <<
					all << all << user.c_str());
				// msg 246: @1 is not grantor of @2 on @3 to @4.
			}

			ERR_post_warning(Arg::Warning(isc_dyn_miss_priv_warning) << all << all << user);
			// msg 247: Warning: @1 on @2 is not granted to @3.
		}
	}
	catch (const Exception& ex)
	{
		ex.stuff_exception(tdbb->tdbb_status_vector);
		DYN_error_punt(true, 255);
		// msg 255: "ERASE RDB$USER_PRIVILEGES failed in REVOKE ALL ON ALL"
	}
}


static void set_field_class_name(Global* gbl, const MetaName& relation, const MetaName& field)
{
/**************************************
 *
 *	s e t _ f i e l d _ c l a s s _ n a m e
 *
 **************************************
 *
 * Functional description
 *	For field level grants, be sure the
 *      field has a unique class name.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_s_f_class, DYN_REQUESTS);

	bool unique = false;

	FOR (REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		RFR IN RDB$RELATION_FIELDS
		WITH RFR.RDB$FIELD_NAME = field.c_str() AND
			RFR.RDB$RELATION_NAME = relation.c_str() AND
		RFR.RDB$SECURITY_CLASS MISSING
	{
		MODIFY RFR
			while (!unique)
		    {
				sprintf(RFR.RDB$SECURITY_CLASS, "%s%" SQUADFORMAT, SQL_FLD_SECCLASS_PREFIX,
				DPM_gen_id(tdbb, MET_lookup_generator(tdbb, "RDB$SECURITY_CLASS"), false, 1));

				unique = true;

				AutoCacheRequest request2(tdbb, drq_s_u_class, DYN_REQUESTS);
				FOR (REQUEST_HANDLE request2 TRANSACTION_HANDLE gbl->gbl_transaction)
					RFR1 IN RDB$RELATION_FIELDS
					WITH RFR1.RDB$SECURITY_CLASS = RFR.RDB$SECURITY_CLASS
				{
					unique = false;
				}
				END_FOR
		    }

			RFR.RDB$SECURITY_CLASS.NULL = FALSE;
		END_MODIFY
	}
	END_FOR
}


static void store_privilege(Global* gbl,
							const MetaName&	object,
							const MetaName&	user,
							const MetaName&	field,
							const TEXT* privilege,
							SSHORT user_type,
							SSHORT obj_type,
							int option,
							const MetaName&	grantor)
{
/**************************************
 *
 *	s t o r e _ p r i v i l e g e
 *
 **************************************
 *
 * Functional description
 *	Does its own cleanup in case of error, so calling
 *	routine should not.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_s_grant, DYN_REQUESTS);

	// need to unwind our own request here!! SM 27-Sep-96

	try {
		STORE(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			PRIV IN RDB$USER_PRIVILEGES
			PRIV.RDB$FIELD_NAME.NULL = TRUE;
			strcpy(PRIV.RDB$RELATION_NAME, object.c_str());
			strcpy(PRIV.RDB$USER, user.c_str());
			strcpy(PRIV.RDB$GRANTOR, grantor.c_str());
			PRIV.RDB$USER_TYPE = user_type;
			PRIV.RDB$OBJECT_TYPE = obj_type;
		{
			if (field.length())
			{
				strcpy(PRIV.RDB$FIELD_NAME, field.c_str());
				PRIV.RDB$FIELD_NAME.NULL = FALSE;
				set_field_class_name(gbl, object, field);
			}
			PRIV.RDB$PRIVILEGE[0] = privilege[0];
			PRIV.RDB$PRIVILEGE[1] = 0;
			PRIV.RDB$GRANT_OPTION = option;
		}
		END_STORE
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 79);
		// msg 79: "STORE RDB$USER_PRIVILEGES failed in grant"
	}
}
