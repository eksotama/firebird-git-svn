/*
 *	PROGRAM:	JRD Data Definition Utility
 *	MODULE:		dyn_delete.epp
 *	DESCRIPTION:	Dynamic data definition - DYN_delete_<x>
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * 24-May-2001 Claudio Valderrama - Forbid zero length identifiers,
 *                                  they are not ANSI SQL compliant.
 * 23-May-2001 Claudio Valderrama - Move here DYN_delete_role.
 * 20-Jun-2001 Claudio Valderrama - Make available DYN_delete_generator.
 */

#include "firebird.h"
#include "dyn_consts.h"
#include <stdio.h>
#include <string.h>

#include "../jrd/common.h"
#include "../dsql/DdlNodes.h"
#include "../jrd/jrd.h"
#include "../jrd/ods.h"
#include "../jrd/tra.h"
#include "../jrd/scl.h"
#include "../jrd/drq.h"
#include "../jrd/flags.h"
#include "../jrd/ibase.h"
#include "../jrd/lls.h"
#include "../jrd/met.h"
#include "../jrd/btr.h"
#include "../jrd/intl.h"
#include "../jrd/dyn.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dyn_proto.h"
#include "../jrd/dyn_proto.h"
#include "../jrd/dyn_dl_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/inf_proto.h"
#include "../jrd/intl_proto.h"
#include "../common/isc_f_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/vio_proto.h"
#include "../common/utils_proto.h"

using MsgFormat::SafeArg;

using namespace Jrd;
using namespace Firebird;


DATABASE DB = STATIC "ODS.RDB";


void DYN_delete_filter( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ d e l e t e _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement that
 *	deletes a blob filter.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_e_filters, DYN_REQUESTS);

	bool found = false;

	Firebird::MetaName f;
	GET_STRING(ptr, f);

	try
	{
		found = false;
		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$FILTERS WITH X.RDB$FUNCTION_NAME = f.c_str()
		{
			ERASE X;
			found = true;
		}
		END_FOR
	}
	catch (const Firebird::Exception& ex)
	{
		Firebird::stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 36);
		// msg 36: "ERASE BLOB FILTER failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 37, f.c_str());
		// msg 37: "Blob Filter %s not found"
	}

	if (*(*ptr)++ != isc_dyn_end) {
		DYN_unsupported_verb();
	}
}


void DYN_delete_generator(Global* gbl, const UCHAR**ptr)
{
/**************************************
 *
 *	D Y N _ d e l e t e _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement that
 *	deletes a generator from rdb$generator but the
 *  space allocated in the page won't be released.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	bool found = false;
	Firebird::MetaName t;
    GET_STRING(ptr, t);

	try
	{
        AutoCacheRequest request(tdbb, drq_e_gens, DYN_REQUESTS);

        found = false;
        FOR (REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
            X IN RDB$GENERATORS
            WITH X.RDB$GENERATOR_NAME EQ t.c_str()
		{
			if (X.RDB$SYSTEM_FLAG != 0)
				DYN_error_punt(false, 272);	// msg 272: "Cannot delete system generator"

		    found = true;

			DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_BEFORE,
				DDL_TRIGGER_DROP_SEQUENCE, t, gbl->sqlText);

            ERASE X;
		}
        END_FOR
    }
	catch (const Firebird::Exception& ex)
	{
		Firebird::stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 213);
		// msg 213: "ERASE GENERATOR failed"
    }

	if (found)
	{
		DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_AFTER,
			DDL_TRIGGER_DROP_SEQUENCE, t, gbl->sqlText);
	}
	else
	{
		DYN_error_punt(false, 214, t.c_str());
	    // msg 214: "Generator %s not found"
	}
}


void DYN_delete_index( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ d e l e t e _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement that
 *	deletes an index.
 *
 **************************************/
	Firebird::MetaName idx_name, rel_name;

	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_e_indices, DYN_REQUESTS);

	bool found = false;
	bool is_expression = false;

	try
	{
		GET_STRING(ptr, idx_name);

		found = false;
		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ idx_name.c_str()
		{
			rel_name = IDX.RDB$RELATION_NAME;
			found = true;

			DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_BEFORE,
				DDL_TRIGGER_DROP_INDEX, idx_name, gbl->sqlText);

			is_expression = !IDX.RDB$EXPRESSION_BLR.NULL;
			ERASE IDX;
		}
		END_FOR
	} //try
	catch (const Firebird::Exception& ex)
	{
		Firebird::stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 47);
		// msg 47: "ERASE RDB$INDICES failed"
	}

	if (found)
	{
		DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_AFTER,
			DDL_TRIGGER_DROP_INDEX, idx_name, gbl->sqlText);
	}
	else
	{
		DYN_error_punt(false, 48);
		// msg 48: "Index not found"
	}

	if (!is_expression)
		if (!DropIndexNode::deleteSegmentRecords(tdbb, gbl->gbl_transaction, idx_name))
		{
			DYN_error_punt(false, 50);
			// msg 50: "No segments found for index"
		}

	while (*(*ptr)++ != isc_dyn_end)
	{
		--(*ptr);
		DYN_execute(gbl, ptr, &rel_name, NULL, NULL, NULL, NULL);
	}
}


void DYN_delete_role( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ d e l e t e _ r o l e
 *
 **************************************
 *
 * Functional description
 *
 *	Execute a dynamic ddl statement that deletes a role with all its
 *      members of the role.
 *
 **************************************/
	int id = -1;
	Firebird::MetaName role_name;

	thread_db* tdbb = JRD_get_thread_data();

	bool found = false;

	try
	{
		Firebird::MetaName user(tdbb->getAttachment()->att_user->usr_user_name);
		user.upper7();

		GET_STRING(ptr, role_name);

		AutoCacheRequest request(tdbb, drq_drop_role, DYN_REQUESTS);
		id = drq_drop_role;

		bool del_role_ok = true;

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			XX IN RDB$ROLES WITH
				XX.RDB$ROLE_NAME EQ role_name.c_str()
		{
			found = true;

			DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_BEFORE,
				DDL_TRIGGER_DROP_ROLE, role_name, gbl->sqlText);

			const Firebird::MetaName role_owner(XX.RDB$OWNER_NAME);

			if (tdbb->getAttachment()->locksmith() || role_owner == user)
			{
				ERASE XX;
			}
			else
			{
				del_role_ok = false;
			}
		}
		END_FOR

		if (del_role_ok)
		{
			request.reset(tdbb, drq_del_role_1, DYN_REQUESTS);
			id = drq_del_role_1;

			// The first OR clause finds all members of the role.
			// The 2nd OR clause finds all privileges granted to the role
			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				PRIV IN RDB$USER_PRIVILEGES WITH
					(PRIV.RDB$RELATION_NAME EQ role_name.c_str() AND
					 PRIV.RDB$OBJECT_TYPE = obj_sql_role)
					OR (PRIV.RDB$USER EQ role_name.c_str() AND
					   PRIV.RDB$USER_TYPE = obj_sql_role)
			{
				ERASE PRIV;
			}
			END_FOR
		}
		else
		{
			DYN_error(false, 191, SafeArg() << user.c_str() << role_name.c_str());
			// only owner of SQL role or USR_locksmith could drop SQL role
			goto do_punt;
		}
	}	// try
	catch (const Firebird::Exception& ex)
	{
		Firebird::stuff_exception(tdbb->tdbb_status_vector, ex);
		const USHORT number = (id == drq_drop_role ? 191 : 62);
		// msg 191: "ERASE RDB$ROLES failed"
		// msg  62: "ERASE RDB$USER_PRIVILEGES failed"
		DYN_error_punt(true, number);
	}

	if (found)
	{
		DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_AFTER,
			DDL_TRIGGER_DROP_ROLE, role_name, gbl->sqlText);
	}
	else
	{
		DYN_error_punt(false, 155, role_name.c_str());
		// msg 155: "Role %s not found"
	}

	return;

do_punt:	// ugly, rethink logic of this function
	ERR_punt();
}


void DYN_delete_shadow( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ d e l e t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *	Delete a shadow.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	if (!tdbb->getAttachment()->locksmith())
	{
		ERR_post(Arg::Gds(isc_adm_task_denied));
	}

	AutoCacheRequest request(tdbb, drq_e_shadow, DYN_REQUESTS);

	try
	{
		const int shadow_number = DYN_get_number(ptr);
		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER EQ shadow_number
		{
			ERASE FIL;
		}
		END_FOR
	}
	catch (const Firebird::Exception& ex)
	{
		Firebird::stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 63);
		// msg 63: "ERASE RDB$FILES failed"
	}

	if (*(*ptr)++ != isc_dyn_end) {
		DYN_unsupported_verb();
	}
}
