/*
 *	PROGRAM:	JRD Data Definition Utility
 *	MODULE:		dyn_mod.epp
 *	DESCRIPTION:	Dynamic data definition - DYN_modify_<x>
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * 2001.5.20: Claudio Valderrama: when changing a domain's name,
 *	if it has dimensions, rdb$field_dimensions should be updated, too.
 * 2001.5.23: Claudio Valderrama: Forbid zero length identifiers,
 *	they are not ANSI SQL compliant.
 * 2001.5.27 Claudio Valderrama: Prevent rdb$field_length from going
 *	out of sync when toggling between char and varchar data types.
 *	This caused check_update_fld_type() to lose ability to detect potentially
 *	dangerous changes. For example, you could alter a field or a domain and
 *	be able to change char(10) to varchar(8).
 *	Unfortunately, Borland chose to have DYN_modify_global_field() and add to the
 *	party DYN_modify_sql_field(); therefore bug fixes should be done twice.
 * 2001.10.08 Claudio Valderrama: put a comment with suggested code to hide
 *	special non-system triggers from user manipulation.
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 * 2002.08.10 Dmitry Yemanov: ALTER VIEW
 */

#include "firebird.h"
#include "dyn_consts.h"
#include <stdio.h>
#include <string.h>

#include "../jrd/common.h"
#include "../jrd/jrd.h"
#include "../jrd/tra.h"
#include "../jrd/scl.h"
#include "../jrd/drq.h"
#include "../jrd/flags.h"
#include "../jrd/ibase.h"
#include "../jrd/lls.h"
#include "../jrd/met.h"
#include "../jrd/btr.h"
#include "../jrd/ini.h"
#include "../jrd/intl.h"
#include "../jrd/dyn.h"
#include "../jrd/ods.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dyn_proto.h"
#include "../jrd/dyn_df_proto.h"
#include "../jrd/dyn_md_proto.h"
#include "../jrd/dyn_ut_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/gds_proto.h"
#include "../jrd/inf_proto.h"
#include "../jrd/intl_proto.h"
#include "../jrd/isc_f_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/vio_proto.h"
#include "../jrd/dsc_proto.h"
#include "../common/utils_proto.h"
#include "../dsql/DdlNodes.h"
#include "../dsql/metd_proto.h"
#include "../jrd/PreparedStatement.h"

using MsgFormat::SafeArg;

using namespace Jrd;
using namespace Firebird;


DATABASE DB = STATIC "ODS.RDB";

static const UCHAR alloc_info[] = { isc_info_allocation, isc_info_end };

static void change_backup_mode(Global*, UCHAR verb);


void DYN_modify_database( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ m o d i f y _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Modify a database.
 *
 **************************************/
	UCHAR s[128];

	thread_db* tdbb = JRD_get_thread_data();
	Jrd::Attachment* attachment = tdbb->getAttachment();

	try {

		INF_database_info(alloc_info, sizeof(alloc_info), s, sizeof(s));

		if (s[0] != isc_info_allocation) {
			goto dyn_punt_84;
		}

		AutoCacheRequest request(tdbb, drq_m_database, DYN_REQUESTS);

		const SSHORT length = gds__vax_integer(s + 1, 2);
		SLONG start = gds__vax_integer(s + 3, length);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			DBB IN RDB$DATABASE
		{
			MODIFY DBB USING
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_security_class:
						if (GET_STRING(ptr, DBB.RDB$SECURITY_CLASS))
							DBB.RDB$SECURITY_CLASS.NULL = FALSE;
						else
							DBB.RDB$SECURITY_CLASS.NULL = TRUE;
						break;

					case isc_dyn_def_file:
						DYN_define_file(gbl, ptr, (SLONG) 0, &start, 84);
						break;

					case isc_dyn_def_difference:
						DYN_define_difference(gbl, ptr);
						break;

					case isc_dyn_drop_difference:
					case isc_dyn_begin_backup:
					case isc_dyn_end_backup:
						change_backup_mode(gbl, verb);
						break;

					case isc_dyn_fld_character_set_name:
						if (!tdbb->getAttachment()->locksmith())
							ERR_post(Arg::Gds(isc_adm_task_denied));

						if (GET_STRING(ptr, DBB.RDB$CHARACTER_SET_NAME))
							DBB.RDB$CHARACTER_SET_NAME.NULL = FALSE;
						else
							DBB.RDB$CHARACTER_SET_NAME.NULL = TRUE;
						break;

					case isc_dyn_fld_collation:
						{
							MetaName collation;
							GET_STRING(ptr, collation);

							if (!DBB.RDB$CHARACTER_SET_NAME.NULL)
							{
								string sql;
								sql.printf("alter character set \"%s\" set default collation \"%s\"",
									PreparedStatement::escapeName(DBB.RDB$CHARACTER_SET_NAME).c_str(),
									PreparedStatement::escapeName(collation).c_str());

								AutoPtr<PreparedStatement> ps(attachment->prepareStatement(tdbb,
									gbl->gbl_transaction, sql));
								ps->execute(tdbb, gbl->gbl_transaction);
							}
						}
						break;

					default:
						--(*ptr);
						DYN_execute(gbl, ptr, NULL, NULL, NULL, NULL, NULL);
					}
				}
			END_MODIFY
		}
		END_FOR
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 84);
		// msg 84: "MODIFY DATABASE failed"
	}

	return;

dyn_punt_84:
	DYN_error_punt(true, 84);
	// msg 84: "MODIFY DATABASE failed"
}


// *************************************
// D Y N _ m o d i f y _ f u n c t i o n
// *************************************
// Its purpose is to change the comment in the function's record and to
// allow changing the entry point and/or the module name.
void DYN_modify_function(Global* gbl, const UCHAR** ptr)
{
	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_m_fun, DYN_REQUESTS);
	bool found = false;

	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$FUNCTIONS
			WITH X.RDB$FUNCTION_NAME EQ t AND
				 X.RDB$PACKAGE_NAME MISSING
		{
			if (!X.RDB$ENGINE_NAME.NULL)
				status_exception::raise(Arg::Gds(isc_dyn_newfc_oldsyntax) << t);

			DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_BEFORE,
				DDL_TRIGGER_ALTER_FUNCTION, t, gbl->sqlText);

			found = true;
			MODIFY X
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_func_module_name:
						GET_STRING(ptr, X.RDB$MODULE_NAME);
						X.RDB$MODULE_NAME.NULL = FALSE;
						break;

					case isc_dyn_func_entry_point:
						GET_STRING(ptr, X.RDB$ENTRYPOINT);
						X.RDB$ENTRYPOINT.NULL = FALSE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			END_MODIFY
		}
		END_FOR
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 92);
		// msg 92: "MODIFY RDB$FUNCTIONS failed"
	}

	if (found)
	{
		DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_AFTER,
			DDL_TRIGGER_ALTER_FUNCTION, t, gbl->sqlText);
	}
	else
	{
		DYN_error_punt(false, 41, t);
		// msg 41: "Function %s not found"
	}
}


void DYN_modify_index( Global* gbl, const UCHAR** ptr)
{
/**************************************
 *
 *	D Y N _ m o d i f y _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Modify an existing index
 *
 **************************************/
	MetaName name;

	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_m_index, DYN_REQUESTS);
	bool found = false;

	try {

		GET_STRING(ptr, name);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ name.c_str()
		{
			found = true;

			DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_BEFORE,
				DDL_TRIGGER_ALTER_INDEX, name, gbl->sqlText);

			MODIFY IDX USING
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_idx_unique:
						IDX.RDB$UNIQUE_FLAG = DYN_get_number(ptr);
						IDX.RDB$UNIQUE_FLAG.NULL = FALSE;
						break;

					case isc_dyn_idx_inactive:
						IDX.RDB$INDEX_INACTIVE = DYN_get_number(ptr);
						IDX.RDB$INDEX_INACTIVE.NULL = FALSE;
						break;

					// For V4 index selectivity can be set only to -1
					case isc_dyn_idx_statistic:
						IDX.RDB$STATISTICS = -1.0;
						IDX.RDB$STATISTICS.NULL = FALSE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			END_MODIFY
		}
		END_FOR
	} // try
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 91);
		// msg 91: "MODIFY RDB$INDICES failed"
	}

	if (found)
	{
		DdlNode::executeDdlTrigger(tdbb, gbl->gbl_transaction, DdlNode::DTW_AFTER,
			DDL_TRIGGER_ALTER_INDEX, name, gbl->sqlText);
	}
	else
	{
		DYN_error_punt(false, 48);
		// msg 48: "Index not found"
	}
}


static void change_backup_mode( Global* gbl, UCHAR verb)
{
/**************************************
 *
 *	c h a n g e _ b a c k u p _ m o d e
 *
 **************************************
 *
 * Functional description
 *	Drop backup difference file for the database,
 *  begin or end backup
 *
 **************************************/
	bool invalid_state = false;

	thread_db* tdbb = JRD_get_thread_data();

	if (!tdbb->getAttachment()->locksmith())
	{
		ERR_post(Arg::Gds(isc_adm_task_denied));
	}

	AutoCacheRequest request(tdbb, drq_d_difference, DYN_REQUESTS);
	bool found = false;

	try {

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$FILES
		{
			if (X.RDB$FILE_FLAGS & FILE_difference)
			{
				found = true;
				switch (verb)
				{
				case isc_dyn_drop_difference:
					ERASE X;
					break;
				case isc_dyn_begin_backup:
					if (X.RDB$FILE_FLAGS & FILE_backing_up) {
						invalid_state = true;
					}
					else
					{
						MODIFY X USING
							X.RDB$FILE_FLAGS |= FILE_backing_up;
						END_MODIFY
					}
					break;
				case isc_dyn_end_backup:
					if (X.RDB$FILE_FLAGS & FILE_backing_up)
					{
						if (X.RDB$FILE_NAME.NULL) {
							ERASE X;
						}
						else
						{
							MODIFY X USING
								X.RDB$FILE_FLAGS &= ~FILE_backing_up;
							END_MODIFY
						}
					}
					else {
						invalid_state = true;
					}
					break;
				}
			}
		}
		END_FOR
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 63);
		// msg 63: ERASE RDB$FILE failed
	}

	if (!found && verb == isc_dyn_begin_backup)
	{
		try
		{
			request.reset(tdbb, drq_s2_difference, DYN_REQUESTS);

			STORE(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				X IN RDB$FILES
			{
				X.RDB$FILE_NAME.NULL = TRUE;
				X.RDB$FILE_FLAGS.NULL = FALSE;
				X.RDB$FILE_FLAGS = FILE_difference | FILE_backing_up;
				X.RDB$FILE_START = 0;
				X.RDB$FILE_START.NULL = FALSE;
				X.RDB$FILE_LENGTH.NULL = TRUE;
				X.RDB$SHADOW_NUMBER.NULL = TRUE;
			}
			END_STORE

			found = true;
		}
		catch (const Exception& ex)
		{
			stuff_exception(tdbb->tdbb_status_vector, ex);
			DYN_error_punt(true, 150);
			// msg 150: STORE RDB$FILES failed
		}
	}

	if (invalid_state)
	{
		DYN_error_punt(false, verb == isc_dyn_begin_backup ? 217 : 218);
		// msg 217: "Database is already in the physical backup mode"
		// msg 218: "Database is not in the physical backup mode"
	}

	if (!found)
	{
		DYN_error_punt(false, verb == isc_dyn_end_backup ? 218 : 215);
		// msg 218: "Database is not in the physical backup mode"
		// msg 215: "Difference file is not defined"
	}
}


// *************************************
// D Y N _ m o d i f y _ m a p p i n g
// *************************************
// It's purpose is to add/drop mapping from OS security name
// to DB security object
void DYN_modify_mapping(Global* gbl, const UCHAR** ptr)
{
	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, drq_m_map, DYN_REQUESTS);
	bool found = false;

	string osName, dbName;
	GET_STRING(ptr, osName);
	const UCHAR op = *(*ptr)++;
	GET_STRING(ptr, dbName);

	// This is FB 2.5 limited implementation!
	// Later it should work with new system table, something like RDB$MAPPING.

	if (dbName != ADMIN_ROLE)
	{
		status_exception::raise(Arg::Gds(isc_no_meta_update) << Arg::Gds(isc_wish_list));
	}

	if (!(tdbb->getAttachment() && tdbb->getAttachment()->locksmith()))
		ERR_post(Arg::Gds(isc_adm_task_denied));

	found = false;
	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		X IN RDB$ROLES
			WITH X.RDB$ROLE_NAME EQ dbName.c_str()
	{
		found = true;
		MODIFY X
			switch (op)
			{
			case isc_dyn_automap_role:
				X.RDB$SYSTEM_FLAG = ROLE_FLAG_DBO | ROLE_FLAG_MAY_TRUST;
				break;

			case isc_dyn_autounmap_role:
				X.RDB$SYSTEM_FLAG = ROLE_FLAG_DBO;
				break;

			default:
				DYN_unsupported_verb();
			}
		END_MODIFY
	}
	END_FOR

	if (!found)
	{
		status_exception::raise(Arg::Gds(isc_no_meta_update) <<
			Arg::Gds(isc_random) << Arg::Str("Missing RDB$ADMIN role in the database"));
	}
}
