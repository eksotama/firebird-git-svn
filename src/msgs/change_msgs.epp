/*
 *	PROGRAM:	Interbase Message file edit program
 *	MODULE:		change_msgs.epp
 *	DESCRIPTION:	Allow limited change of messages in database
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include "../jrd/ib_stdio.h"
#include "../jrd/y_ref.h"
#include "../jrd/ibase.h"
#include "../jrd/common.h"

#include <stdlib.h>

#ifdef HAVE_STRING_H
#include <string.h>
#endif



DATABASE DB = "msg.fdb";

#define FAC_SQL_POSITIVE	14
#define FAC_SQL_NEGATIVE	13

#define LOWER_A         'a'
#define UPPER_A         'A'
#define LOWER_Z         'z'
#define UPPER_Z         'Z'

static void ascii_str_upper(UCHAR *);
static void explicit_print(TEXT *);
static bool get_sql_class(UCHAR *);
static bool get_sql_subclass(UCHAR *);
#ifdef NOT_USED_OR_REPLACED
static bool get_symbol(UCHAR *);
#endif
static bool mustget(SCHAR *);
static int translate(SCHAR *, SCHAR *, SSHORT);


int main( int argc, char **argv)
{
/**************************************
 *
 *	m a i n
 *
 **************************************
 *
 * Functional description
 *	Top level routine.  
 *
 **************************************/
	SCHAR facility[20], text[256], module[32], routine[32];
	UCHAR sql_class[32], sql_sub_class[32];
	SCHAR input[200], yesno[100];
	SCHAR symbol[30];
	SCHAR nstring[32];
	SSHORT count;
	SSHORT sql_number;
	SSHORT msg_number;

	ib_printf("\nHit Ctrl-D (or Ctrl-Z) at prompt to exit level\n");
	ib_printf
		("You will be prompted for facility, module, routine and message text\n");
	ib_printf
		("You *must* enter module and routine names for each message; be prepared\n");
	ib_printf("You may assign an optional symbol for the message\n");
	ib_printf
		("Escape sequences may be entered and will be translated to single bytes\n");

	READY;
	START_TRANSACTION;

	for (;;) {
		ib_printf("Facility: ");
		if (!ib_gets(facility))
			break;
		count = 0;
		msg_number = 0;
		ascii_str_upper((UCHAR*) facility);
		FOR X IN FACILITIES WITH X.FACILITY = facility
			count++;
			for (;;) {
				bool sys_error = false;

				ib_printf("Message number (%d) ? ", msg_number + 1);
				if (!ib_gets(input))
					break;
				if (!input[0])
					msg_number++;
				else
					msg_number = atoi(input);
				if (msg_number <= 0)
					break;
				ib_printf("Facility: %s\n", X.FACILITY);
				FOR Y IN MESSAGES WITH
					Y.FAC_CODE EQ X.FAC_CODE AND Y.NUMBER EQ msg_number;

					ib_printf(" Message: %d\n", Y.NUMBER);
					ib_printf("  Module: %s\n", Y.MODULE);
					ib_printf(" Routine: %s\n", Y.ROUTINE);
					ib_printf("    Text: ");
					explicit_print(Y.TEXT);
					ib_printf("\n");
					ib_printf("  Symbol: %s\n", Y.SYMBOL);
				END_FOR

				FOR Z IN SYSTEM_ERRORS WITH X.FAC_CODE EQ Z.FAC_CODE AND
					Z.NUMBER EQ msg_number;
					ib_printf("SQLCODE: %d\n", Z.SQL_CODE);
					ib_printf("   SQL_CLASS:    %s\n", Z.SQL_CLASS);
					ib_printf("SQL_SUBCLASS: %s\n", Z.SQL_SUBCLASS);
					sys_error = true;
				END_FOR

				ib_printf(" Modify? ");
				if (mustget(yesno) && (yesno[0] == 'y' || yesno[0] == 'Y')) {
					module[0] = 0;
					ib_printf(" Module: ");
					if (!ib_gets(module))
						break;
					routine[0] = 0;
					ib_printf("Routine: ");
					if (!ib_gets(routine))
						break;
					text[0] = 0;
					ib_printf("   Text: ");
					if (!ib_gets(text))
						break;
					symbol[0] = 0;
					ib_printf(" Symbol: ");
					if (!ib_gets(symbol))
						break;
					if (sys_error || X.FAC_CODE == 0) {
						ib_printf("SQLCODE: ");
						if (mustget(nstring))
							sql_number = atoi(nstring);
						if (!get_sql_class(sql_class))
							/* continue */ ;
						if (!get_sql_subclass(sql_sub_class))
							/* continue */ ;
					}

					FOR Y IN MESSAGES WITH
						Y.FAC_CODE EQ X.FAC_CODE AND Y.NUMBER EQ msg_number;
						MODIFY Y USING
							if (module[0])
								strcpy(Y.MODULE, (char*) module);
							if (routine[0])
								strcpy(Y.ROUTINE, (char*) routine);
							if (text[0])
								while (!translate
									   (text, Y.TEXT, sizeof(Y.TEXT))) {
									ib_printf
										("Message too long: max length: %d\n",
										 sizeof(Y.TEXT));
									mustget(text);
								}
							if (symbol[0])
								strcpy(Y.SYMBOL, (char*) symbol);
						END_MODIFY;
					END_FOR;

					FOR Z IN SYSTEM_ERRORS WITH
						Z.FAC_CODE EQ X.FAC_CODE AND Z.NUMBER EQ msg_number;
						MODIFY Z USING
							if (symbol[0])
								strcpy(Z.GDS_SYMBOL, (char*) symbol);
							if (sql_number != 0)
								Z.SQL_CODE = sql_number;
							if (sql_class[0])
								strcpy(Z.SQL_CLASS, (char*) sql_class);
							if (sql_sub_class[0])
								strcpy(Z.SQL_SUBCLASS, (char*) sql_sub_class);
						END_MODIFY;
					END_FOR;
				}
			}
		END_FOR;
		if (!count) {
			ib_printf("Facilty %s not found\n  Known facilities are:\n",
					  facility);
			FOR F IN FACILITIES SORTED BY F.FACILITY
				ib_printf("    %s\n", F.FACILITY);
			END_FOR;
		}
	}

	ib_printf("\n\nCommitting changes...");
	COMMIT;
	FINISH;
	ib_printf("done.\n");

	exit(FINI_OK);
}


static void ascii_str_upper( UCHAR * str)
{
/**************************************
 *
 *      a s c i i _ s t r _ u p p e r
 *
 **************************************
 *
 * Functional description
 *      change a string to all upper case
 *
 **************************************/

	while (*str) {
		/* subtract 32 if necessary */

		if (*str >= LOWER_A && *str <= LOWER_Z)
			*str += (UPPER_A - LOWER_A);
		str++;
	}
}


static void explicit_print( TEXT * string)
{
/**************************************
 *
 *	e x p l i c i t _ p r i n t
 *
 **************************************
 *
 * Functional description
 *	Let it all hang out: print line
 *      with explicit \n \b \t \f etc.
 *      to make changing messages easy
 *
 **************************************/
	TEXT *p;

	p = string;

	while (*p) {
		switch (*p) {
		case '\n':
			ib_putchar('\\');
			ib_putchar('n');
			break;
		case '\t':
			ib_putchar('\\');
			ib_putchar('t');
			break;
		case '\f':
			ib_putchar('\\');
			ib_putchar('f');
			break;
		case '\b':
			ib_putchar('\\');
			ib_putchar('b');
			break;
		case '\r':
			ib_putchar('\\');
			ib_putchar('r');
			break;
		case '\v':
			ib_putchar('\\');
			break;
		case '\\':
			ib_putchar('\\');
			ib_putchar('\\');
			break;
		case '\"':
			ib_putchar('\\');
			ib_putchar('\"');
			break;
		case '\'':
			ib_putchar('\\');
			ib_putchar('\'');
			break;
		default:
			ib_putchar(*p);
		}
		*p++;
	}
}


static bool get_sql_class( UCHAR * sql_class)
{
/**************************************
 *
 *	g e t _ s q l _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	get a two character sql_class string
 *	return true if we get one, otherwise false
 *
 **************************************/
	SSHORT length;

	while (1) {
		ib_printf("   SQLCLASS: ");
		ib_gets((char*) sql_class);
		length = strlen((char*) sql_class);
		if (!length)
			break;

		if (length == 2)
			return true;
		else
			ib_fprintf(ib_stderr, "Sqlclass is two characters!\n");
	}

	return false;
}


static bool get_sql_subclass( UCHAR * sql_sub_class)
{
/**************************************
 *
 *	g e t _ s q l _ s u b c l a s s
 *
 **************************************
 *
 * Functional description
 *	get a three character sql_subclass string
 *	return true if we get one, otherwise false
 *
 **************************************/
	SSHORT length;

	while (1) {
		ib_printf("SQLSUBCLASS: ");
		ib_gets((char*) sql_sub_class);
		length = strlen((char*) sql_sub_class);
		if (!length)
			break;

		if (length == 3)
			return true;
		else
			ib_fprintf(ib_stderr, "Sqlsubclass is three characters!\n");
	}
	return false;
}

#ifdef NOT_USED_OR_REPLACED
static bool get_symbol( UCHAR * symbol)
{
/**************************************
 *
 *	g e t _ s y m b o l
 *
 **************************************
 *
 * Functional description
 *	insist on getting the symbol
 *	return true when we get one
 *
 **************************************/
	while (true) {
		ib_fprintf(ib_stderr, "Symbols are required for system errors!\n");
		ib_printf(" Symbol: ");
		ib_gets((char*) symbol);
		if (strlen((char*) symbol))
			return true;
	}
}
#endif

static bool mustget( SCHAR * s)
{
/**************************************
 *
 *	m u s t g e t
 *
 **************************************
 *
 * Functional description
 *	gets & returns a string.  Returns false
 *	if string is empty.
 *
 **************************************/

	if (!ib_gets((char*) s))
		return false;

	return (s[0] != 0);
}


static int translate( SCHAR * source, SCHAR * target, SSHORT length)
{
/**************************************
 *
 *	t r a n s l a t e
 *
 **************************************
 *
 * Functional description
 * 	make explicit escape sequences into
 *	ascii, returns length ok?
 *
 **************************************/
	SCHAR *p, *q;

	p = target;
	q = source;

	while (*q) {
		if (!--length)
			return 0;
		if (*q == '\\') {
			*q++;
			switch (*q) {
			case 'n':
				*p++ = '\n';
				break;
			case 't':
				*p++ = '\t';
				break;
			case 'f':
				*p++ = '\f';
				break;
			case 'a':
				*p++ = '\a';
				break;
			case 'b':
				*p++ = '\b';
				break;
			case 'r':
				*p++ = '\r';
				break;
			case 'v':
				*p++ = '\v';
				break;
			case '\\':
				*p++ = '\\';
				break;
			case '\"':
				*p++ = '\"';
				break;
			case '\'':
				*p++ = '\'';
				break;
			default:
				ib_printf
					("\n\n*** Escape sequence not understood; being copied unchanged ***\n\n");
				*p++ = '\\';
				*p++ = *q;
			}
			*q++;
		}
		else
			*p++ = *q++;
	}
	*p = 0;

	return 1;
}
